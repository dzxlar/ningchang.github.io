<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="dzxblog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="dzxblog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dzxblog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>dzxblog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">dzxblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/《亿级流量网站架构核心技术》学习笔记-（二）-——-负载均衡与反向代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/《亿级流量网站架构核心技术》学习笔记-（二）-——-负载均衡与反向代理/" itemprop="url">《亿级流量网站架构核心技术》学习笔记 （二） —— 负载均衡与反向代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T17:02:52+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="《亿级流量网站架构核心技术》学习笔记-（二）-——-负载均衡与反向代理"><a href="#《亿级流量网站架构核心技术》学习笔记-（二）-——-负载均衡与反向代理" class="headerlink" title="《亿级流量网站架构核心技术》学习笔记 （二） —— 负载均衡与反向代理"></a>《亿级流量网站架构核心技术》学习笔记 （二） —— 负载均衡与反向代理</h2><blockquote>
<p>单实例不能支撑用户请求的时候，就需要进行扩容</p>
</blockquote>
<p>如果用户访问 <a href="https://www.tmall.com" target="_blank" rel="external">https://www.tmall.com</a> 的方式访问请求，浏览器首先会查询DNS服务器所对应IP，然后通过IP访问对应服务器</p>
<h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><p>www.tmall.com 域名映射多个IP，但是如果某台服务器重启或出现故障，DNS存在一定缓存时间，故障后切换时间长，且没有对后端服务进行心跳检测和失败重试的机制</p>
<ul>
<li>外网DNS通过GSLB(全局负载均衡)进行流量调度<ul>
<li>查看公网ip<ul>
<li>站长工具 - DNS查询 </li>
</ul>
</li>
</ul>
</li>
<li>内网DNS通过简单的轮询负载均衡<ul>
<li>HaProxy 和 Nginx</li>
</ul>
</li>
</ul>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx通常用于七层负载，限制一定的吞吐量，为了提升吞吐量会在DNS和Nginx中引入接入层(LVS、F5做4层负载均衡)</p>
<p><strong>首先通过DNS解析LVS/F5，然后LVS/F5转发给Nginx，再由Nginx转发给后端RealServer</strong></p>
<p>业务开发人员只需关心Nginx层面，LVS/F5会由运维人员维护</p>
<p>Nginx1.9.0以后开始支持TCP(ngx_stream_upstream_module)四层负载均衡</p>
<h4 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h4><p>二层负载均衡<br>通过改写报文的目标MAC地址为上游服务器MAC地址</p>
<ol>
<li>源Ip地址和目标Ip地址不变</li>
<li>负载均衡服务器和真实服务器共享一个VIP</li>
</ol>
<p>四层负载均衡</p>
<ol>
<li>根据端口将报文转发到上游服务器(不同的Ip的地址 + 端口)</li>
</ol>
<p>七层负载均衡</p>
<ol>
<li>根据端口号和应用层协议的主机名、URL、转发报文到上游服务器</li>
</ol>
<h2 id="负载均衡核心"><a href="#负载均衡核心" class="headerlink" title="负载均衡核心"></a>负载均衡核心</h2><ol>
<li>上游服务器(upstream server)配置</li>
<li>负载均衡算法</li>
<li>失败重试机制</li>
<li>服务器心跳检查</li>
</ol>
<hr>
<h3 id="upstream-配置上游服务器（真实业务服务器）"><a href="#upstream-配置上游服务器（真实业务服务器）" class="headerlink" title="upstream 配置上游服务器（真实业务服务器）"></a>upstream 配置上游服务器（真实业务服务器）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>IP地址和端口</li>
<li>权重：默认为1.权重越高分配给这台服务器的请求越多(如上每3次请求就有1次转发给8080，另外2次转发给8070)</li>
</ul>
<h3 id="proxy-pass-处理用户请求"><a href="#proxy-pass-处理用户请求" class="headerlink" title="proxy_pass 处理用户请求"></a>proxy_pass 处理用户请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    proxy_pass http://realServer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当访问Nginx时，会将请求反向代理到realServer配置的upstream server中</li>
</ul>
<hr>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ul>
<li>round-robin：轮询(默认)</li>
<li>ip_hash：根据客户IP进行均衡负载（即相同的ip分配给同一个upstream server</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    ip_hash;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>hash 算法：根据请求uri进行负载均衡，可以使用Nginx变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    hash $uri;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>hash key[consistant]:对某一个key进行哈希或者使用一致性hash算法进行负载均衡</p>
<ul>
<li>使用hash算法存在的问题<ul>
<li>当添加/删除一台服务器时，将导致很多key被重新负载均衡到不同服务器：所以建议使用一致性hash算法，只有少数key被重新负载均衡到不同服务器中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>根据动态consistent_key指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    hash $consistent_key consistent;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>location指定一致性hash，会优先考虑请求参数cat，若没有，则根据请求uri进行负载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    set $consistent_key $arg_cat;</div><div class="line">    if($consistent_key = &quot;&quot;)&#123;</div><div class="line">        set $consistent_key $request_uri;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    server 172.16.42.81:8080 max_fails=2 fail_timeout=10s weight=1;</div><div class="line">    server 172.16.42.81:8070 max_fails=2 fail_timeout=10s weight=2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当fail_timeout时间内失败了max_fails次，则认为该服务器不可用，然后摘掉该服务器，fail_timeouth后再次将服务器加入到存活服务器列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    proxy_connect_timeout 5s;</div><div class="line">    proxy_read_timeout 5s;</div><div class="line">    proxy_send_timeout 5s;</div><div class="line">    </div><div class="line">    proxy_next_upstream error timeout;</div><div class="line">    proxy_next_upstream_timeout 10s;</div><div class="line">    proxy_next_upstream_tries 2;</div><div class="line">    </div><div class="line">    proxy_pass http://realServer;</div><div class="line">    </div><div class="line">    add_header upstream_addr $upstream_addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><blockquote>
<p>Nginx默认采用惰性策略，Nginx上夜班提供health_check进行主动健康检查; 也可以集成nginx_upstream_check_module模块进行健康检查</p>
</blockquote>
<h3 id="nginx-upstream-check-module"><a href="#nginx-upstream-check-module" class="headerlink" title="nginx_upstream_check_module"></a>nginx_upstream_check_module</h3><h4 id="TCP心跳检查"><a href="#TCP心跳检查" class="headerlink" title="TCP心跳检查"></a>TCP心跳检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2;</div><div class="line">    check interval=3000 rise=1 fail=3 timeout=2000 type=tcp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>interval 每个3s检测一次</li>
<li>fail 失败多少次之后，目标不存活</li>
<li>rise 成功多少次后，目标存活，并可以处理请求</li>
<li>timeout 请求超时时间配置</li>
</ul>
<h4 id="Http心跳检查"><a href="#Http心跳检查" class="headerlink" title="Http心跳检查"></a>Http心跳检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2;</div><div class="line">    check interval=3000 rise=1 fail=3 timeout=2000 type=http;</div><div class="line">    check_http_send &quot;HEAD /status HTTP/1.0\r\n\r\n&quot;;</div><div class="line">    check_http_expect_alive http_2xx http_3xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>check_http_send 检查时发出的http请求内容</li>
<li>check_http_expect_alive 当上游服务器返回匹配的响应码，则认为上游服务器存活</li>
</ul>
<p>注意：间隔时间不能太短，否则可能因为心跳检查包太多造成上游服务器挂掉，同事设置合理超时时间</p>
<p>安装健康检查模块需要先打nginx_upstream_check_module补丁，不然该模块不工作</p>
<hr>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><h3 id="域名上游服务器"><a href="#域名上游服务器" class="headerlink" title="域名上游服务器"></a>域名上游服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    server c0.3.cn;</div><div class="line">    server c1.3.cn;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Nginx社区版：在Nginx解析配置文件时将域名解析成IP地址并记到upstream上，当这两个域名对应ip发生变化时，不会更新，Nginx商业版支持动态更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_pass http://c0.3.cn</div></pre></td></tr></table></figure>
<p>支持动态更新</p>
<h3 id="备份上游服务器"><a href="#备份上游服务器" class="headerlink" title="备份上游服务器"></a>备份上游服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="不可用上游服务器"><a href="#不可用上游服务器" class="headerlink" title="不可用上游服务器"></a>不可用上游服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2 down;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream realServer &#123;</div><div class="line">    server 172.16.42.81:8080 weight=1;</div><div class="line">    server 172.16.42.81:8070 weight=2 backup;</div><div class="line">    keepalive 100;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>keepalive 每个Worker进程与上游服务器可缓存的空闲连接最大数量，当超过这个数量时，最近最少使用的链接被关闭</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    ## 支持keep-alive</div><div class="line">    proxy_http_version 1.1;</div><div class="line">    ## 支持http/1.0</div><div class="line">    proxy_set_header Connection &quot;Connection:Keep-Alive&quot;;</div><div class="line">    proxy_pass http://realServer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总长连接数 = 空闲连接池 + 释放连接池</p>
<p>具体环境</p>
<ul>
<li>空闲连接池太小，连接不够用，需要不断建立连接</li>
<li>空闲连接池太多，空闲连接太多，还未使用就超时</li>
</ul>
<p><strong>注意：尽量只对小报文开启长连接</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/《亿级流量网站架构核心技术》学习笔记-（一-——-基本原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/《亿级流量网站架构核心技术》学习笔记-（一-——-基本原则/" itemprop="url">《亿级流量网站架构核心技术》学习笔记 （一 ) —— 基本原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T17:01:30+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="《亿级流量网站架构核心技术》学习笔记-（一-——-基本原则"><a href="#《亿级流量网站架构核心技术》学习笔记-（一-——-基本原则" class="headerlink" title="《亿级流量网站架构核心技术》学习笔记 （一 ) —— 基本原则"></a>《亿级流量网站架构核心技术》学习笔记 （一 ) —— 基本原则</h2><ul>
<li>设计系统参考<strong>墨菲定律</strong><ol>
<li>凡是可能出错的事必定会出错</li>
<li>任何事情都没有表面看起来那么简单</li>
<li>所有事情都比预想更长</li>
<li>如果担心某种情况发生，这个事情可能发生</li>
</ol>
</li>
<li>系统划分参考<strong>康威定律</strong><ol>
<li><a href="https://yq.aliyun.com/articles/8611" target="_blank" rel="external">微服务基础-康威定律</a></li>
<li>系统架构是公司组织架构的反映</li>
<li>应该按照业务闭环对系统/组织架构划分，实现闭环/高内聚/低耦合</li>
<li>如果沟通出现问题，应该考虑进行系统和组织架构调整</li>
<li>在合适的时机进行系统拆分</li>
</ol>
</li>
<li>合理利用资源参考<strong>二八定律(帕雷托法则)</strong><ol>
<li>80%的结果取决于20%的原因</li>
</ol>
</li>
</ul>
<h3 id="高并发原则"><a href="#高并发原则" class="headerlink" title="高并发原则"></a>高并发原则</h3><ul>
<li><strong>无状态</strong><blockquote>
<ol>
<li>应用是无状态的，比较容易进行水平扩展</li>
<li>实际生产环境: 应用无状态;配置文件有状态;</li>
<li>比如: 不同机房读取不同数据源，通过配置文件或者配置中心指定</li>
</ol>
</blockquote>
</li>
<li><strong>拆分</strong><blockquote>
<p>根据业务环境考虑采取”单一系统”还是”按功能拆封模块”<br>拆分情况</p>
<ul>
<li>系统维度：系统功能/模块拆分<ul>
<li>商品系统、购物车、结算、订单系统等</li>
</ul>
</li>
<li>功能维度：功能再拆分<ul>
<li>优惠券系统拆分:创建券、领券、用券系统</li>
</ul>
</li>
<li>读写维度：根据读写比例特征进行拆分<ul>
<li>读服务，可考虑缓存</li>
<li>写服务，可考虑分库分表</li>
<li>聚合读取，可考虑异构拆分系统</li>
</ul>
</li>
<li>AOP维度：根据访问特征，进行AOP拆分<ul>
<li>商品详情页分为CDN和页面渲染系统</li>
</ul>
</li>
<li>模块维度：基础和代码维护特征进行拆分<ul>
<li>Service、Dao、Web三层结构</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>服务化</strong></p>
<blockquote>
<p>总结: 进程内调用 -&gt; 单机远程调用 -&gt;<br>集群手动注册 -&gt; 自动注册和发现 -&gt;<br>服务分组/隔离/路由 -&gt; 服务治理(限流/白名单)</p>
</blockquote>
</li>
<li><p><strong>消息队列</strong></p>
<blockquote>
<ul>
<li>处理不需要同步调用的服务或者订阅一些系统关心<br>的变化从而达到服务解耦(一对多消费)、异步处理<br>、流量削峰/缓冲等</li>
<li>比如:订单系统、定期送系统、订单风控系统等</li>
<li>如果订阅者太多，那么订阅单个消息队列会成为瓶颈。考虑对消息队列进行镜像复制</li>
<li>注意事项：处理生产消息失败、消息重复接收等问题<ul>
<li>数据重复接收<ul>
<li>大流量缓冲:牺牲强一致性、保证最终一致性<ul>
<li>比如: 扣减库存: Redis扣减 -&gt; 记录日志<br>-&gt; 同步Worker -&gt; 库存DB</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>同步Worker设计时，须考虑并发处理和重复处理<br>比如使用扫描处理(部分表) 还是 集群处理(Map-Reduce).考虑是否对订单列表增加字段:处理人、处理状态、处理时间、失败次数等<ul>
<li>数据校对<ul>
<li>通过消息异步机制，可能存在数据丢失情况<br>通过数据校对保证数据一致和完整性（比如.<br>通过Worker定期扫描原始表，对业务数据进行校对</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>数据异构</strong></p>
</li>
<li><p><strong>数据闭环</strong></p>
<blockquote>
<p>例如商品详情页. 由于数据来源过多，影响服务器稳定,最好的办法是将数据进行异构存储,形成数据闭环</p>
<ol>
<li>数据异构<ul>
<li>通过MQ接收数据变更、然后原子化存储到合适引擎，如Redis或者KV存储</li>
</ul>
</li>
<li>数据聚合<ul>
<li>&lt;可选&gt; 数据从多个数据源拿出，然后前端进行聚合</li>
</ul>
</li>
<li>前端展示<ul>
<li>通过一次或者少量次数拿到所需数据</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>总结：数据异构和数据闭环是同一个概念，目的实现数据的自我控制，当其他系统出问题时不影响自己系统。或者自己出问题不影响其他系统。一般通过消息队列进行数据分发</strong></p>
<ul>
<li><p>缓存银弹</p>
<ul>
<li>客户端缓存<ul>
<li>浏览器缓存/客户端应用缓存<ul>
<li>设置Expires/Cache-Control进行控制</li>
<li>针对实时性不高的数据</li>
</ul>
</li>
</ul>
</li>
<li>客户端网络<ul>
<li>代理服务器开启缓存<ul>
<li>APP缓存静态资源文件</li>
</ul>
</li>
</ul>
</li>
<li>广域网<ul>
<li>代理服务器/镜像服务器/p2p</li>
</ul>
</li>
<li><p>源站及源站网络</p>
<ul>
<li>接入层缓存/应用层缓存/分布式缓存/静态化、伪静态化/服务器操作系统提供的缓存<ul>
<li>接入式缓存：Nginx搭建接入层:URL重写、一致性hash、proxy_cache、proxy_cache_lock、shared_dict(Nginx+Lua)</li>
<li>应用层缓存：使用Tomcat:使用堆内缓存和堆外缓存。local redis cache（多机使用主从机制同步数据)</li>
<li>分布式缓存：常见分片规则一致性hash</li>
</ul>
</li>
</ul>
</li>
<li><p>并发化</p>
</li>
</ul>
</li>
</ul>
<h2 id="高可用原则"><a href="#高可用原则" class="headerlink" title="高可用原则"></a>高可用原则</h2><ul>
<li>降级<ul>
<li>对于一个高可用服务，很重要的设计是降级开关。<ol>
<li>开关集中化管理</li>
<li>可降级的多级读服务</li>
<li>开关前置化</li>
<li>业务降级</li>
</ol>
</li>
</ul>
</li>
<li>限流<ul>
<li>限流的目的：防止恶意请求流量、恶意攻击或者防止流量超出峰值<ol>
<li>恶意请求流量只到cache</li>
<li>对于穿透到后端应用的流量，通过Nginx的limit模块进行处理</li>
<li>对于恶意Ip通过Nginx deny屏蔽</li>
</ol>
</li>
</ul>
</li>
<li><p>切流量</p>
<ul>
<li><p>比如：多机房某个机房挂了、某个服务器挂了、某个机架挂了都需要切流量。</p>
<ol>
<li>DNS：切换机房入口</li>
<li>HttpDNS：主要APP环境下，客户端分配流量入口，绕过运营商LocalDNS实现精准流量调度</li>
<li>LVS：切换故障Nginx接入层</li>
<li>Nginx：切换故障应用层</li>
</ol>
</li>
<li><p>可回滚<br>通过版本号实现追溯回滚。比如：数据回滚、事务回滚、部署版本回滚、静态资源回滚等</p>
</li>
</ul>
</li>
</ul>
<h2 id="业务设计原则"><a href="#业务设计原则" class="headerlink" title="业务设计原则"></a>业务设计原则</h2><ul>
<li>防重设计<blockquote>
<p>考虑防重key或者防重表</p>
</blockquote>
</li>
<li>幂等设计</li>
<li>流程可定义</li>
<li>状态与状态机</li>
<li>后台操作系统可反馈</li>
<li>后台系统审批化</li>
<li>文档和注释</li>
<li>备份</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【设计模式】行为型模式——命令模式（Command-Pattern）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【设计模式】行为型模式——命令模式（Command-Pattern）/" itemprop="url">【设计模式】行为型模式——命令模式（Command Pattern）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T13:37:15+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote>
<p><strong>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</strong></p>
</blockquote>
<p> <strong>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</strong></p>
<h2 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h2><p>(1) 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。<br>       (2) 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。<br>       (3) 可以比较容易地设计一个命令队列或宏命令（组合命令）。<br>       (4) 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。</p>
<h2 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h2><p> <strong>使用命令模式可能会导致某些系统有过多的具体命令类。</strong>因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p> (1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。<br>       (2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。<br>       (3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。<br>       (4) 系统需要将一组操作组合在一起形成宏命令。</p>
<h2 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h2><blockquote>
<p><strong>Hystrix</strong></p>
</blockquote>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="http://img.blog.csdn.net/20170418143436113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<blockquote>
<p><strong>命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。</strong>每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。<br>       <strong>命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。</strong></p>
</blockquote>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">abstract class Command &#123;  </div><div class="line">    public abstract void execute();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Invoker &#123;  </div><div class="line">    private Command command;  </div><div class="line">      </div><div class="line">    //构造注入  </div><div class="line">    public Invoker(Command command) &#123;  </div><div class="line">        this.command = command;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //设值注入  </div><div class="line">    public void setCommand(Command command) &#123;  </div><div class="line">        this.command = command;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //业务方法，用于调用命令类的execute()方法  </div><div class="line">    public void call() &#123;  </div><div class="line">        command.execute();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ConcreteCommand extends Command &#123;  </div><div class="line">    private Receiver receiver; //维持一个对请求接收者对象的引用  </div><div class="line">  </div><div class="line">    public void execute() &#123;  </div><div class="line">        receiver.action(); //调用请求接收者的业务处理方法action()  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Receiver &#123;  </div><div class="line">    public void action() &#123;  </div><div class="line">        //具体操作  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>每一个具体命令类对应一个请求的处理者（接收者），通过向请求发送者注入不同的具体命令对象可以使得相同的发送者对应不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【设计模式】行为性模式——模板方法模式-Template-Method-Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【设计模式】行为性模式——模板方法模式-Template-Method-Pattern/" itemprop="url">【设计模式】行为性模式——模板方法模式(Template Method Pattern)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T13:36:35+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote>
<p><strong>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</strong></p>
</blockquote>
<p><strong>模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。</strong></p>
<h2 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h2><p>  (1) 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。<br>       (2) 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。<br>       (3) 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。<br>       (4) 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</p>
<h2 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h2><p>   需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。</p>
<h2 id="模式适用场景"><a href="#模式适用场景" class="headerlink" title="模式适用场景"></a>模式适用场景</h2><p> (1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。<br>(2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。<br>(3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</p>
<h2 id="模式实际应用"><a href="#模式实际应用" class="headerlink" title="模式实际应用"></a>模式实际应用</h2><blockquote>
<p>线程AQS类</p>
</blockquote>
<hr>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p><img src="http://img.blog.csdn.net/20170418114145140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><blockquote>
<p> 一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。</p>
</blockquote>
<hr>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">abstract class AbstractClass   </div><div class="line">&#123;  </div><div class="line">	//模板方法  </div><div class="line">	public void TemplateMethod()   </div><div class="line">	&#123;  </div><div class="line">	        PrimitiveOperation1();  </div><div class="line">	        PrimitiveOperation2();  </div><div class="line">	        PrimitiveOperation3();  </div><div class="line">	&#125;  </div><div class="line">  </div><div class="line">	//基本方法—具体方法  </div><div class="line">	public void PrimitiveOperation1()   </div><div class="line">	&#123;  </div><div class="line">	    //实现代码  </div><div class="line">	&#125;  </div><div class="line">  </div><div class="line">	//基本方法—抽象方法  </div><div class="line">    public abstract void PrimitiveOperation2();      </div><div class="line">  </div><div class="line">	//基本方法—钩子方法  </div><div class="line">	public virtual void PrimitiveOperation3()&#123;  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class ConcreteClass : AbstractClass   </div><div class="line">&#123;  </div><div class="line">	public override void PrimitiveOperation2()   </div><div class="line">	&#123;  </div><div class="line">	    //实现代码  </div><div class="line">	&#125;  </div><div class="line">	  </div><div class="line">	public override void PrimitiveOperation3()   </div><div class="line">	&#123;  </div><div class="line">	    //实现代码  </div><div class="line">	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，具体子类的基本方法将覆盖父类中定义的基本方法，子类的钩子方法也将覆盖父类的钩子方法，从而可以通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。</strong></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【设计模式】Lambda表达式实现工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【设计模式】Lambda表达式实现工厂模式/" itemprop="url">【设计模式】Lambda表达式实现工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T13:35:43+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简单原始例子"><a href="#简单原始例子" class="headerlink" title="简单原始例子"></a>简单原始例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Shape &#123;</div><div class="line">	void draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Rectangle implements Shape &#123;</div><div class="line">	@Override</div><div class="line">	public void draw() &#123;</div><div class="line">		System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Circle implements Shape &#123;</div><div class="line">	@Override</div><div class="line">	public void draw() &#123;</div><div class="line">		System.out.println(&quot;Inside Circle::draw() method.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory &#123;</div><div class="line">	//use getShape method to get object of type shape</div><div class="line">	public Shape getShape(String shapeType)&#123;</div><div class="line">		if(shapeType == null)&#123;</div><div class="line">		return null;</div><div class="line">		&#125;</div><div class="line">		if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;</div><div class="line">		return new Circle();</div><div class="line">		&#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;</div><div class="line">		return new Rectangle();</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用Lambada实现工厂模式"><a href="#使用Lambada实现工厂模式" class="headerlink" title="使用Lambada实现工厂模式"></a>使用Lambada实现工厂模式</h3><p><strong>Lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它</strong></p>
<p>方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Shape&gt; circleSupplier = Circle::new;</div><div class="line">Circle circle = circleSupplier.get();</div></pre></td></tr></table></figure>
<hr>
<p>根据构造方法引用的原理，我们可以重写之前的代码，定义一个Map来保存shape name 和它对应的构造方法引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final static Map&lt;String, Supplier&lt;Shape&gt;&gt; map = new HashMap&lt;&gt;();</div><div class="line">static &#123;</div><div class="line">	map.put(&quot;CIRCLE&quot;, Circle::new);</div><div class="line">	map.put(&quot;RECTANGLE&quot;, Rectangle::new);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用这个map来实例化不同的shapes"><a href="#使用这个map来实例化不同的shapes" class="headerlink" title="使用这个map来实例化不同的shapes"></a>使用这个map来实例化不同的shapes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ShapeFactory &#123;</div><div class="line">final static Map&lt;String, Supplier&lt;Shape&gt;&gt; map = new HashMap&lt;&gt;();</div><div class="line">	static &#123;</div><div class="line">		map.put(&quot;CIRCLE&quot;, Circle::new);</div><div class="line">		map.put(&quot;RECTANGLE&quot;, Rectangle::new);</div><div class="line">	&#125;</div><div class="line">	public Shape getShape(String shapeType)&#123;</div><div class="line">		Supplier&lt;Shape&gt; shape = map.get(shapeType.toUpperCase());</div><div class="line">		if(shape != null) &#123;</div><div class="line">			return shape.get();</div><div class="line">		&#125;</div><div class="line">		throw new IllegalArgumentException(&quot;No such shape &quot; + shapeType.toUpperCase());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>使用lambada表达式实现的工厂方法来创建shape对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	Supplier&lt;ShapeFactory&gt; shapeFactory = ShapeFactory::new;</div><div class="line">	//call draw method of circle</div><div class="line">	shapeFactory.get().getShape(&quot;circle&quot;).draw();</div><div class="line">	//call draw method of Rectangle</div><div class="line">	shapeFactory.get().getShape(&quot;rectangle&quot;).draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 Shape::new可以被看作为lambda表达式的简写形式。尽管方法引用不一定会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。</p>
<p>如果 Shape 构造函数需要多个参数，那么你就需要重新实现自己的Supplier</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&gt; new Circe(args)</div></pre></td></tr></table></figure>
<p><a href="https://blog.maxleap.cn/archives/1300" target="_blank" rel="external">原文转载</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【设计模式】结构型模式——组合模式（Composite-Pattern）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【设计模式】结构型模式——组合模式（Composite-Pattern）/" itemprop="url">【设计模式】结构型模式——组合模式（Composite Pattern）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T13:35:15+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="组合模式定义"><a href="#组合模式定义" class="headerlink" title="组合模式定义"></a>组合模式定义</h3><blockquote>
<p><strong>组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。</strong></p>
</blockquote>
<hr>
<blockquote>
<p>组合模式为处理树形结构提供了一种较为完美的解决方案，它描述了如何将容器和叶子进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器和叶子。</p>
</blockquote>
<h3 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h3><ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li>
<li>在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。<h3 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h3></li>
<li>在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。</li>
<li>在一个使用面向对象语言开发的系统中需要处理一个树形结构。</li>
<li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://img.blog.csdn.net/20170405112743406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理</strong></p>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">abstract class Component &#123;  </div><div class="line">    public abstract void add(Component c); //增加成员  </div><div class="line">    public abstract void remove(Component c); //删除成员  </div><div class="line">    public abstract Component getChild(int i); //获取成员  </div><div class="line">    public abstract void operation();  //业务方法  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Leaf extends Component &#123;  </div><div class="line">    public void add(Component c) &#123;   </div><div class="line">        //异常处理或错误提示   </div><div class="line">    &#125;     </div><div class="line">          </div><div class="line">    public void remove(Component c) &#123;   </div><div class="line">        //异常处理或错误提示   </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public Component getChild(int i) &#123;   </div><div class="line">        //异常处理或错误提示  </div><div class="line">        return null;   </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public void operation() &#123;  </div><div class="line">        //叶子构件具体业务方法的实现  </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Composite extends Component &#123;  </div><div class="line">    private ArrayList&lt;Component&gt; list = new ArrayList&lt;Component&gt;();  </div><div class="line">      </div><div class="line">    public void add(Component c) &#123;  </div><div class="line">        list.add(c);  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public void remove(Component c) &#123;  </div><div class="line">        list.remove(c);  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public Component getChild(int i) &#123;  </div><div class="line">        return (Component)list.get(i);  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public void operation() &#123;  </div><div class="line">        //容器构件具体业务方法的实现  </div><div class="line">        //递归调用成员构件的业务方法  </div><div class="line">        for(Object obj:list) &#123;  </div><div class="line">            ((Component)obj).operation();  </div><div class="line">        &#125;  </div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【设计模式】行为型模式——策略模式-Strategy-Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【设计模式】行为型模式——策略模式-Strategy-Pattern/" itemprop="url">【设计模式】行为型模式——策略模式(Strategy Pattern)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T13:34:51+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="策略模式定义"><a href="#策略模式定义" class="headerlink" title="策略模式定义"></a>策略模式定义</h3><blockquote>
<p><strong>实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径</strong></p>
</blockquote>
<p><strong>策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开</strong></p>
<h3 id="策略模式优点"><a href="#策略模式优点" class="headerlink" title="策略模式优点"></a>策略模式优点</h3><ul>
<li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li>
<li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</li>
<li>策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。</li>
<li>使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</li>
<li>策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。<h3 id="策略模式缺点"><a href="#策略模式缺点" class="headerlink" title="策略模式缺点"></a>策略模式缺点</h3></li>
</ul>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</li>
<li>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</li>
<li>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。</li>
<li>一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://img.blog.csdn.net/20170401153719791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ul>
<li>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理</li>
<li>环境类是需要使用算法的类。在一个系统中可以存在多个环境类，它们可能需要重用一些相同的算法</li>
</ul>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">abstract class AbstractStrategy &#123;  </div><div class="line">    public abstract void algorithm(); //声明抽象算法  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class ConcreteStrategyA extends AbstractStrategy &#123;  </div><div class="line">    //算法的具体实现  </div><div class="line">    public void algorithm() &#123;  </div><div class="line">       //算法A  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Context &#123;  </div><div class="line">private AbstractStrategy strategy; //维持一个对抽象策略类的引用  </div><div class="line">  </div><div class="line">    public void setStrategy(AbstractStrategy strategy) &#123;  </div><div class="line">        this.strategy= strategy;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    //调用策略类中的算法  </div><div class="line">    public void algorithm() &#123;  </div><div class="line">        strategy.algorithm();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Context context = new Context();  </div><div class="line">AbstractStrategy strategy;  </div><div class="line">strategy = new ConcreteStrategyA(); //可在运行时指定类型  </div><div class="line">context.setStrategy(strategy);  </div><div class="line">context.algorithm();</div></pre></td></tr></table></figure>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="策略模式的两个典型应用"><a href="#策略模式的两个典型应用" class="headerlink" title="策略模式的两个典型应用"></a>策略模式的两个典型应用</h4><ul>
<li>Java SE的容器布局管理</li>
</ul>
<hr>
<blockquote>
<p> 策略模式用于算法的自由切换和扩展，它是应用较为广泛的设计模式之一。策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决某一问题，同时可以方便地更换算法或者增加新的算法。只要涉及到算法的封装、复用和切换都可以考虑使用策略模式</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【设计模式】创建型模式——原型模式-Prototype-Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【设计模式】创建型模式——原型模式-Prototype-Pattern/" itemprop="url">【设计模式】创建型模式——原型模式(Prototype Pattern)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T13:27:34+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原型模式的定义"><a href="#原型模式的定义" class="headerlink" title="原型模式的定义"></a>原型模式的定义</h3><blockquote>
<p><strong>使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</strong></p>
</blockquote>
<p>注意：通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象</p>
<h3 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h3><ul>
<li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</li>
<li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</li>
<li>原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</li>
<li><p>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p>
<h3 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h3></li>
<li><p>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p>
</li>
<li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li>
<li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://img.blog.csdn.net/20170401114608369?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class ConcretePrototype implements Prototype</div><div class="line">&#123;</div><div class="line">	private String  attr; //成员属性</div><div class="line">	public void  setAttr(String attr)</div><div class="line">	&#123;</div><div class="line">	    this.attr = attr;</div><div class="line">	&#125;</div><div class="line">	public String  getAttr()</div><div class="line">	&#123;</div><div class="line">	    return this.attr;</div><div class="line">	&#125;</div><div class="line">	public Prototype  clone() //克隆方法</div><div class="line">	&#123;</div><div class="line">	    Prototype  prototype = new ConcretePrototype(); //创建新对象</div><div class="line">	    prototype.setAttr(this.attr);</div><div class="line">	    return prototype;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Prototype obj1  = new ConcretePrototype();</div><div class="line">obj1.setAttr(&quot;andy&quot;);</div><div class="line">Prototype obj2  = obj1.clone();</div></pre></td></tr></table></figure>
<p><strong>Java中可以直接使用Object提供的clone()方法来实现对象的克隆</strong><br><strong>需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class ConcretePrototype implements  Cloneable</div></pre></td></tr></table></figure>
<hr>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="Java语言中的clone-方法满足"><a href="#Java语言中的clone-方法满足" class="headerlink" title="Java语言中的clone()方法满足"></a>Java语言中的clone()方法满足</h4><p>(1) 对任何对象x，都有x.clone() != x，即<strong>克隆对象与原型对象不是同一个对象</strong><br>(2) 对任何对象x，都有x.clone().getClass() == x.getClass()，即<strong>克隆对象与原型对象的类型一样</strong><br>(3) 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</p>
<h4 id="为了获取对象的一份拷贝，我们可以直接利用Object类的clone-方法，具体步骤如下："><a href="#为了获取对象的一份拷贝，我们可以直接利用Object类的clone-方法，具体步骤如下：" class="headerlink" title="为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下："></a>为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</h4><p>(1) 在派生类中覆盖基类的clone()方法，并声明为public；<br>(2) 在派生类的clone()方法中，调用super.clone()；<br>(3)派生类需实现Cloneable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class ConcretePrototype implements  Cloneable</div><div class="line">&#123;</div><div class="line">……</div><div class="line">public Prototype  clone()</div><div class="line">&#123;</div><div class="line">　　Object object = null;</div><div class="line">　　try &#123;</div><div class="line">　　　　　object = super.clone();</div><div class="line">　　&#125; catch (CloneNotSupportedException exception) &#123;</div><div class="line">　　　　　System.err.println(&quot;Not support cloneable&quot;);</div><div class="line">　　&#125;</div><div class="line">　　return (Prototype )object;</div><div class="line">&#125;</div><div class="line">……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prototype obj1  = new ConcretePrototype();</div><div class="line">Prototype obj2  = obj1.clone();</div></pre></td></tr></table></figure>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><blockquote>
<p><strong>主要区别在于是否支持引用类型的成员变量的复制</strong></p>
</blockquote>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><blockquote>
<p>如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址</p>
</blockquote>
<p><strong>当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制</strong></p>
<p>浅拷贝<br><img src="http://img.blog.csdn.net/20170401132708197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> <strong>在Java中，通过覆盖Object类的clone()方法可以实现浅拷贝</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public CustomObject clone()</div><div class="line">       &#123;</div><div class="line">              Object obj = null;</div><div class="line">              try</div><div class="line">              &#123;</div><div class="line">                     obj = super.clone();</div><div class="line">                     return (CustomObject)obj;</div><div class="line">              &#125;</div><div class="line">              catch(CloneNotSupportedException  e)</div><div class="line">              &#123;</div><div class="line">                     System.out.println(&quot;不支持复制！&quot;);</div><div class="line">                     return null;</div><div class="line">              &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><blockquote>
<p>在深拷贝中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深拷贝将原型对象的所有引用对象也复制一份给克隆对象。</p>
</blockquote>
<p><strong>在深拷贝中，除了对象本身被复制外，对象所包含的所有成员变量也将复制</strong></p>
<p><img src="http://img.blog.csdn.net/20170401133153278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<blockquote>
<p>在Java中，如果需要实现深拷贝，可以通过序列化(Serialize)等方式来实现。</p>
</blockquote>
<hr>
<blockquote>
<p>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深拷贝</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//使用序列化技术实现深克隆</div><div class="line">      public CustomObject deepClone() throws  IOException, ClassNotFoundException, OptionalDataException</div><div class="line">      &#123;</div><div class="line">             //将对象写入流中</div><div class="line">             ByteArrayOutputStream bao=new  ByteArrayOutputStream();</div><div class="line">             ObjectOutputStream oos=new  ObjectOutputStream(bao);</div><div class="line">             oos.writeObject(this);</div><div class="line">            </div><div class="line">             //将对象从流中取出</div><div class="line">             ByteArrayInputStream bis=new  ByteArrayInputStream(bao.toByteArray());</div><div class="line">             ObjectInputStream ois=new  ObjectInputStream(bis);</div><div class="line">             return  (CustomObject)ois.readObject();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>深拷贝实现了原型对象和克隆对象的完全独立，对任意克隆对象的修改都不会给其他对象产生影响，是一种更为理想的克隆实现方式</strong></p>
<hr>
<blockquote>
<p>Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。</p>
</blockquote>
<hr>
<blockquote>
<p>  原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用，</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【设计模式】结构型模式——适配器模式（Adaper-Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【设计模式】结构型模式——适配器模式（Adaper-Pattern/" itemprop="url">【设计模式】结构型模式——适配器模式（Adaper Pattern)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T13:27:04+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="适配器模式定义"><a href="#适配器模式定义" class="headerlink" title="适配器模式定义"></a>适配器模式定义</h3><blockquote>
<p><strong>将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</strong></p>
</blockquote>
<hr>
<p><strong>在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系</strong></p>
<h3 id="适配器优点"><a href="#适配器优点" class="headerlink" title="适配器优点"></a>适配器优点</h3><ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ul>
<p>类适配器模式还具有如下优点：</p>
<ul>
<li>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li>
</ul>
<p>对象适配器模式还具有如下优点：</p>
<ul>
<li>一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</li>
</ul>
<h3 id="适配器缺点"><a href="#适配器缺点" class="headerlink" title="适配器缺点"></a>适配器缺点</h3><p>类适配器模式的缺点如下：</p>
<ul>
<li>对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</li>
</ul>
<p>对象适配器模式的缺点如下：</p>
<ul>
<li>与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://img.blog.csdn.net/20170331155156128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Adapter extends Target &#123;  </div><div class="line">    private Adaptee adaptee; //维持一个对适配者对象的引用  </div><div class="line">      </div><div class="line">    public Adapter(Adaptee adaptee) &#123;  </div><div class="line">        this.adaptee=adaptee;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public void request() &#123;  </div><div class="line">        adaptee.specailRequest(); //转发调用  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>
<h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><blockquote>
<p>类适配器模式和对象适配器模式最大的区别<strong>在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系</strong></p>
</blockquote>
<h3 id="类适配器结构"><a href="#类适配器结构" class="headerlink" title="类适配器结构"></a>类适配器结构</h3><p><img src="http://img.blog.csdn.net/20170331172347545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="典型类适配器代码"><a href="#典型类适配器代码" class="headerlink" title="典型类适配器代码"></a>典型类适配器代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Adapter extends Adaptee implements Target &#123;  </div><div class="line">    public void request() &#123;  </div><div class="line">        specificRequest();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="双向适配器"><a href="#双向适配器" class="headerlink" title="双向适配器"></a>双向适配器</h3><blockquote>
<p>在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20170331174102303?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Adapter implements Target,Adaptee &#123;  </div><div class="line">    //同时维持对抽象目标类和适配者的引用  </div><div class="line">    private Target target;  </div><div class="line">    private Adaptee adaptee;  </div><div class="line">      </div><div class="line">    public Adapter(Target target) &#123;  </div><div class="line">        this.target = target;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public Adapter(Adaptee adaptee) &#123;  </div><div class="line">        this.adaptee = adaptee;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public void request() &#123;  </div><div class="line">        adaptee.specificRequest();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public void specificRequest() &#123;  </div><div class="line">        target.request();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际开发中很少适用双向适配器。</p>
<h3 id="认适配器模式-Default-Adapter-Pattern-或缺省适配器模式"><a href="#认适配器模式-Default-Adapter-Pattern-或缺省适配器模式" class="headerlink" title="认适配器模式(Default Adapter Pattern)或缺省适配器模式"></a>认适配器模式(Default Adapter Pattern)或缺省适配器模式</h3><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【设计模式】创建型模式——建造者模式（Builder-Pattern）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【设计模式】创建型模式——建造者模式（Builder-Pattern）/" itemprop="url">【设计模式】创建型模式——建造者模式（Builder Pattern）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T13:26:33+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="建造者模式定义"><a href="#建造者模式定义" class="headerlink" title="建造者模式定义"></a>建造者模式定义</h3><blockquote>
<p><strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</strong></p>
</blockquote>
<hr>
<blockquote>
<p>例如： 王者荣耀内的英雄角色。他们有多个组成部分（技能、着装、五官等）构成一个复杂的角色对象。但每个角色的组成部分又有差异，但创建步骤都大同小异。最后将各组成部分装配成一个完整的人物。</p>
</blockquote>
<hr>
<h3 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h3><ul>
<li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li>
</ul>
<h3 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h3><ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://img.blog.csdn.net/20170331113755091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Product  &#123;</div><div class="line">       private  String partA; //定义部件，部件可以是任意类型，包括值类型和引用类型</div><div class="line">       private  String partB;</div><div class="line">       private  String partC;</div><div class="line">       //partA的Getter方法和Setter方法省略</div><div class="line">       //partB的Getter方法和Setter方法省略</div><div class="line">       //partC的Getter方法和Setter方法省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">abstract class Builder &#123;</div><div class="line">     //创建产品对象</div><div class="line">       protected  Product product=new Product();</div><div class="line">      </div><div class="line">       public  abstract void buildPartA();</div><div class="line">       public  abstract void buildPartB();</div><div class="line">       public  abstract void buildPartC();</div><div class="line">      </div><div class="line">     //返回产品对象</div><div class="line">       public  Product getResult() &#123;</div><div class="line">              return  product;</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Director &#123;</div><div class="line">       private  Builder builder;</div><div class="line">      </div><div class="line">       public  Director(Builder builder) &#123;</div><div class="line">              this.builder=builder;</div><div class="line">       &#125;</div><div class="line">      </div><div class="line">       public  void setBuilder(Builder builder) &#123;</div><div class="line">              this.builder=builer;</div><div class="line">       &#125;</div><div class="line">      </div><div class="line">     //产品构建与组装方法</div><div class="line">       public Product construct() &#123;</div><div class="line">              builder.buildPartA();</div><div class="line">              builder.buildPartB();</div><div class="line">              builder.buildPartC();</div><div class="line">              return builder.getResult();</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	//可通过配置文件实现</div><div class="line">	Builder  builder = new ConcreteBuilder(); </div><div class="line">	Director director = new  Director(builder);</div><div class="line">	Product product = director.construct();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="建造者和抽象工厂比较"><a href="#建造者和抽象工厂比较" class="headerlink" title="建造者和抽象工厂比较"></a>建造者和抽象工厂比较</h3><ul>
<li>与抽象工厂模式相比， 建造者模式返回一个组装好的完整产品 ，而 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li>
<li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li>
<li>如果将抽象工厂模式看成 汽车配件生产工厂 ，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg"
               alt="dzx" />
          <p class="site-author-name" itemprop="name">dzx</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">108</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dzx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
