<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="dzxblog">
<meta property="og:url" content="http://yoursite.com/page/12/index.html">
<meta property="og:site_name" content="dzxblog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dzxblog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/12/"/>





  <title>dzxblog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">dzxblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/线程笔记——synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/线程笔记——synchronized/" itemprop="url">线程笔记——synchronized</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:17:35+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class ThreadA extends Thread&#123;</div><div class="line"></div><div class="line">	private Count count;</div><div class="line">	</div><div class="line">	public ThreadA(Count count)&#123;</div><div class="line">		this.count = count;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		count.add();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Count &#123;</div><div class="line"></div><div class="line">	private int num = 0;</div><div class="line">	/**</div><div class="line">	 * synchronized</div><div class="line">	 * </div><div class="line">	 */</div><div class="line">	public void add()&#123;</div><div class="line">		synchronized(this)&#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(51);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			num += 1; </div><div class="line">			System.out.println(&quot;[&quot;+Thread.currentThread().getName()+&quot;]&quot; + &quot;:&quot; + num);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public int getNum() &#123;</div><div class="line">		return num;</div><div class="line">	&#125;</div><div class="line">	public void setNum(int num) &#123;</div><div class="line">		this.num = num;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		Count count = new Count();</div><div class="line">		for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">			ThreadA t = new ThreadA(count);</div><div class="line">			t.start();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(1010);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(&quot;5个线程最后的值&quot;+count.getNum());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[Thread-0]:1</div><div class="line">[Thread-1]:2</div><div class="line">[Thread-2]:3</div><div class="line">[Thread-4]:4</div><div class="line">[Thread-3]:5</div><div class="line">5个线程最后的值5</div></pre></td></tr></table></figure>
<h3 id="如果不加synchronized关键字，数据会错误"><a href="#如果不加synchronized关键字，数据会错误" class="headerlink" title="如果不加synchronized关键字，数据会错误"></a>如果不加synchronized关键字，数据会错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[Thread-0]:1</div><div class="line">[Thread-1]:2</div><div class="line">[Thread-2]:3</div><div class="line">[Thread-4]:4</div><div class="line">[Thread-3]:5</div><div class="line">5个线程最后的值3</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>保证同一时刻最多只有一个线程执行该段代码</strong><br>可修饰于方法和代码块</p>
</blockquote>
<p>修饰在方法上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">synchronized methodName()&#123;...&#125;</div></pre></td></tr></table></figure>
<p>修饰在代码块上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">methodName()&#123;</div><div class="line">	synchronized(Object)&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="synchronized隐式锁特性"><a href="#synchronized隐式锁特性" class="headerlink" title="synchronized隐式锁特性"></a>synchronized隐式锁特性</h3><p>① Object可以是参数本身、指定对象、this<br>② 不推荐使用this和方法参数，而是指定一个小的对象（隐式锁/同步锁/互斥锁）<br>③ 虽然修饰的地方不尽相同，最终都是锁在一个对象上面<br>④ 默认修饰对象本身，等同synchronized(this)<br>⑤ <strong>之所以叫隐式锁是因为指定一个Object对象作为锁，和它持有相同对象锁的地方将产生互斥性，而不是只有当前代码块或者方法体。另一个相对显示锁不需要加锁或者解锁操作</strong></p>
<p>隐式锁规则</p>
<p>① 当两个并发线程访问同一个对象中的synchronized同步代码块时，一个时间内只有一个线程可以执行，另一个线程必须等待当前线程执行完这个代码块才能继续执行<br>②当一个线程访问一个对象中的synchronized同步代码块时，另外一个线程仍然可以访问该对象的非同步代码块<br>③ 以上规则对其他对象锁同样适用</p>
<p>为了适应高并发以及快速响应的要求，性能以及执行效率从低到高排序</p>
<blockquote>
<p>方法体 &lt; 方法块 （synchronized(this)）<br>原因：方法体在方法外面排队加锁，进入方法体，分配资源还需要一定的时间</p>
</blockquote>
<hr>
<blockquote>
<p><strong>private byte[] lock = new byte[1];</strong><br>synchronized(this) &lt; <strong>synchronized(lock)</strong><br>原因：锁的对象不一样，锁是对象，加锁和解锁都需要释放锁对象，对象越小越好（所以造一个1字节的对象最好）</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ol>
<li>如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。</li>
<li>类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的 synchronized 同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问 synchronized 同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁</li>
<li>访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响</li>
<li>当一个线程访问一个对象中的synchronized同步代码块时，另外一个线程仍然可以访问该对象的非同步代码块</li>
<li>类级别锁被特定类的所有示例共享，它用于控制对 static 成员变量以及 static 方法的并发访问。具体用法与对象级别锁相似</li>
<li><strong>互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized 关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加 1，相应地，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁便被释放了。由于 synchronized 同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁</strong></li>
<li>使用 synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj 为对象的引用，如果获取了 obj 对象上的对象级别锁，在并发访问 obj 对象时时，便会在其 synchronized 代码处阻塞等待，直到获取到该 obj对象的对象级别锁。当 obj 为 this 时，便是获取当前对象的对象级别锁</li>
</ol>
</blockquote>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="synchronized-的另个一重要作用：内存可见性"><a href="#synchronized-的另个一重要作用：内存可见性" class="headerlink" title="synchronized 的另个一重要作用：内存可见性"></a>synchronized 的另个一重要作用：内存可见性</h3><blockquote>
<p>加锁（synchronized 同步）的功能不仅仅局限于互斥行为，同时还存在另外一个重要的方面：内存可见性。<strong>我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且还希望确保当一个线程修改了对象状态后，其他线程能够看到该变化</strong>。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果</strong>。为了确保所有的线程都能看到共享变量的最新值，可以在所有执行读操作或写操作的线程上加上同一把锁</p>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/java-concurrency/images/synchronous.jpg" alt="这里写图片描述"></p>
<p>当线程 A 执行某个同步代码块时，线程 B 随后进入由同一个锁保护的同步代码块，这种情况下可以保证，当锁被释放前，A 看到的所有变量值（锁释放前，A 看到的变量包括 y 和 x）在 B 获得同一个锁后同样可以由 B 看到。换句话说，当线程 B 执行由锁保护的同步代码块时，可以看到线程 A 之前在同一个锁保护的同步代码块中的所有操作结果。如果在线程 A unlock M 之后，线程 B 才进入 lock M，那么线程 B 都可以看到线程 A unlock M 之前的操作，可以得到 i=1，j=1。如果在线程 B unlock M 之后，线程 A 才进入 lock M，那么线程 B 就不一定能看到线程 A 中的操作，因此 j 的值就不一定是 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class  SynchronizedInteger  </div><div class="line">&#123;  </div><div class="line">    private int value;  </div><div class="line"></div><div class="line">    public synchronized int get()&#123;  </div><div class="line">        return value;  </div><div class="line">    &#125;  </div><div class="line">    public synchronized void set(int value)&#123;  </div><div class="line">        this.value = value;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>对 set 和 get 方法进行了同步，加上了同一把对象锁，这样 get 方法可以看到 set 方法中 value 值的变化，从而每次通过 get 方法取得的 value 的值都是最新的 value 值</strong></p>
<h3 id="Conllection线程安全的API"><a href="#Conllection线程安全的API" class="headerlink" title="Conllection线程安全的API"></a>Conllection线程安全的API</h3><blockquote>
<p><strong>集合本质上是非多线程安全的，当多个线程与集合交互时，为了使它多线程安全，必须采取额外的措施</strong></p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20170327101917021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>注意：在 Java 语言中，大部分的线程安全类都是相对线程安全的，它能保证对这个对象单独的操作时线程安全的，我们在调用的时候不需要额外的保障措施，<strong>但是对于一些特定的连续调用</strong>，就可能需要在调用端使用额外的同步手段来保证调用的正确性。例如 Vector、HashTable、Collections的synchronizedXxxx()方法包装的集合等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//为了安全起见，仅使用同步列表的一个引用，这样可以确保控制了所有访问  </div><div class="line">        //集合必须同步化，这里是一个List  </div><div class="line">		List&lt;String&gt; nameList = Collections.synchronizedList(new ArrayList&lt;String&gt;());</div><div class="line"></div><div class="line">        //nameList中的add方法是同步方法，会获取nameList实例的对象锁  </div><div class="line">        nameList.add(&quot;zhangsan&quot;);  </div><div class="line">        nameList.add(&quot;lisi&quot;);  </div><div class="line">        nameList.add(&quot;wanger&quot;);  </div><div class="line">        nameList.add(&quot;hanfei&quot;);  </div><div class="line"></div><div class="line">        //获取nameList实例的对象锁，  </div><div class="line">        //迭代时，阻塞其他线程调用add或remove等方法修改元素  </div><div class="line">        synchronized ( nameList ) &#123;  </div><div class="line">            Iterator&lt;String&gt; iter = nameList.iterator();  </div><div class="line">            while ( iter.hasNext() ) &#123;  </div><div class="line">                String s = (String) iter.next();  </div><div class="line">                System.out.println(&quot;found string: &quot; + s + &quot;, length=&quot; + s.length());  </div><div class="line">            &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://wiki.jikexueyuan.com/project/java-concurrency/synchronized.html" target="_blank" rel="external">多线程文档参考</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/线程笔记——Thread常用方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/线程笔记——Thread常用方法/" itemprop="url">线程笔记——Thread常用方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:16:26+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程的中断机制"><a href="#线程的中断机制" class="headerlink" title="线程的中断机制"></a>线程的中断机制</h3><p>第一种方法: Thread.stop() （已废弃）<br>【缺点】线程不安全，已不再使用</p>
<p>第二种方法: <strong>Thread.interrupt()</strong></p>
<p>当一个线程运行时，另一个线程可以调用对应的 Thread 对象的 interrupt()方法来中断它，该方法只是在目标线程中设置一个标志，表示它已经被中断，并立即返回。</p>
<p><strong>如果只是单纯的调用 interrupt()方法，线程并没有实际被中断，会继续往下执行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class InteruptThread implements Runnable &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">        </div><div class="line">		boolean stop = false;</div><div class="line">		</div><div class="line">		while(!stop)&#123;</div><div class="line">			System.out.println(&quot;This Thread is Running ......&quot;);</div><div class="line">			long time = System.currentTimeMillis();</div><div class="line">			while((System.currentTimeMillis() - time &lt; 1000))&#123;</div><div class="line">				 </div><div class="line">			&#125;</div><div class="line">			//当interrupt=true时，需要去处理它的中断状态，不然线程会一直运行</div><div class="line">			if(Thread.currentThread().isInterrupted())&#123;</div><div class="line">				Thread.currentThread().interrupt();</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;This Thread Exit Under Request&quot;);</div><div class="line">	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		</div><div class="line">		Thread t = new Thread(new InteruptThread(),&quot;Interupt&quot;);</div><div class="line">		System.out.println(&quot;InteruptThread starting ...&quot;);</div><div class="line">		t.start();</div><div class="line">		Thread.sleep(3000);</div><div class="line">		System.out.println(&quot;InteruptThread interupted&quot;);</div><div class="line">		</div><div class="line">		t.interrupt();</div><div class="line">		</div><div class="line">		System.out.println(&quot;线程是否中断----&gt;&quot;+t.isInterrupted());</div><div class="line">		Thread.sleep(3000);</div><div class="line">		</div><div class="line">		System.out.println(&quot;Stop Application&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">InteruptThread starting ...</div><div class="line">This Thread is Running ......</div><div class="line">This Thread is Running ......</div><div class="line">This Thread is Running ......</div><div class="line">InteruptThread interupted</div><div class="line">线程是否中断----&gt;true</div><div class="line">This Thread Exit Under Request</div><div class="line">Stop Application</div></pre></td></tr></table></figure>
<h3 id="如果去掉if语句判断去处理中断状态，线程一直会一直运行-形成死循环）"><a href="#如果去掉if语句判断去处理中断状态，线程一直会一直运行-形成死循环）" class="headerlink" title="如果去掉if语句判断去处理中断状态，线程一直会一直运行(形成死循环）"></a>如果去掉if语句判断去处理中断状态，线程一直会一直运行(形成死循环）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">InteruptThread starting ...</div><div class="line">This Thread is Running ......</div><div class="line">This Thread is Running ......</div><div class="line">This Thread is Running ......</div><div class="line">InteruptThread interupted</div><div class="line">线程是否中断----&gt;true</div><div class="line">This Thread is Running ......</div><div class="line">This Thread is Running ......</div><div class="line">This Thread is Running ......</div><div class="line">Stop Application</div><div class="line">This Thread is Running ......</div><div class="line">This Thread is Running ......</div></pre></td></tr></table></figure>
<p><strong>注意：一定要对Thread.isInterrupted()状态进行处理</strong></p>
<h3 id="补充（yield-和join-使用）"><a href="#补充（yield-和join-使用）" class="headerlink" title="补充（yield()和join()使用）"></a>补充（yield()和join()使用）</h3><ul>
<li>join 方法用线程对象调用，如果在一个线程 A 中调用另一个线程 B 的 join 方法，线程 A 将会等待线程 B 执行完毕后再执行。</li>
<li>yield 可以直接用 Thread 类调用，yield 让出 CPU 执行权给同等级的线程，如果没有相同级别的线程在等待 CPU 的执行权，则该线程继续执行。</li>
</ul>
<h3 id="守护线程（后台运行线程）"><a href="#守护线程（后台运行线程）" class="headerlink" title="守护线程（后台运行线程）"></a>守护线程（后台运行线程）</h3><p>守护线程不需要关心它何时结束，进程结束，守护线程自动结束</p>
<p>不要在守护线程中执行业务逻辑操作（比如对数据的读写等）</p>
<p>必须在启动线程前标记守护线程<br><strong>setDeamon(true);</strong></p>
<p><strong>Java垃圾回收、内存管理就是一个守护线程</strong></p>
<p>注意</p>
<ul>
<li><strong>setDaemon(true)必须在调用线程的 start()方法之前设置，否则会跑出 IllegalThreadStateException 异常。</strong></li>
<li><strong>在守护线程中产生的新线程也是守护线程。</strong></li>
<li><strong>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑</strong></li>
</ul>
<h3 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h3><ol>
<li>当线程执行 Thread.sleep()时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断；</li>
<li>当线程碰到一条 wait()语句时，它会一直阻塞到接到通知（notify()）、被中断或经过了指定毫秒时间为止（若制定了超时值的话）</li>
<li>线程阻塞与不同 I/O 的方式有多种。常见的一种方式是 InputStream的read()方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；</li>
<li>线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得 synchronized 语句必须的锁时阻塞）。</li>
</ol>
<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>方便管理线程，并且可以为某些线程设置相同特定的属性<br>例如:setDeamon()、设置未处理异常的处理方法、设置统一的安全策略等</p>
<p>每个ThreadGroup都可以包含一组子线程或者一组子线程组</p>
<p>在一个进程中线程组是以树形存在</p>
<p>system线程组是所有线程的顶级父线程组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取当前线程的线程组</div><div class="line">Thread.currentThread().getThreadGroup()</div></pre></td></tr></table></figure>
<ul>
<li>Java中允许对一个线程组中所有线程进行操作</li>
<li>Java多线程另一个重要的特性就是线程安全。线程组机制允许通过分组来区分不同特性的线程</li>
</ul>
<p><strong>线程池和线程组区别：线程组方便管理线程对象。线程池管理线程的声明周期，复用线程，减少创建销毁进程的开销</strong></p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="当前线程副本ThreadLocal"><a href="#当前线程副本ThreadLocal" class="headerlink" title="当前线程副本ThreadLocal"></a>当前线程副本ThreadLocal</h4><ul>
<li><strong>ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每个线程都可以独立的改变自己的副本</strong>（Local想表达的意思）</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170324121110440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=" "></p>
<ul>
<li>remove() 是jdk5以后新增的方法，java会自动垃圾回收变量，调用该方法加快垃圾回收的速度</li>
<li>get()/set() 得到/设置ThreadLocal的值<br>-initialValue()  返回变量的初始值，只执行一次。若缺省，直接返回一个null<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalValue &#123;</div><div class="line"></div><div class="line">	private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;()&#123;</div><div class="line">		protected Integer initialValue() &#123;return 0;&#125;;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	public Integer nextNum()&#123;</div><div class="line">		seqNum.set(seqNum.get() + 1);</div><div class="line">		return seqNum.get();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public ThreadLocal&lt;Integer&gt; getThreadLocal()&#123;</div><div class="line">		return seqNum;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		ThreadLocalValue value = new ThreadLocalValue();</div><div class="line">		</div><div class="line">		TestClient t1 = new TestClient(value);</div><div class="line">		TestClient t2 = new TestClient(value);</div><div class="line">		TestClient t3 = new TestClient(value);</div><div class="line">		</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		t3.start();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	static class TestClient extends Thread&#123;</div><div class="line">		private ThreadLocalValue tlv = null;</div><div class="line">		public TestClient(ThreadLocalValue tlv)&#123;</div><div class="line">			this.tlv = tlv;</div><div class="line">		&#125;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">				System.out.println(&quot;thread[&quot;+Thread.currentThread().getName()+&quot;] ---&gt; value : &quot;+tlv.nextNum());</div><div class="line">			&#125;</div><div class="line">			tlv.getThreadLocal().remove();</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="console-1"><a href="#console-1" class="headerlink" title="console"></a>console</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">thread[Thread-2] ---&gt; value : 1</div><div class="line">thread[Thread-1] ---&gt; value : 1</div><div class="line">thread[Thread-0] ---&gt; value : 1</div><div class="line">thread[Thread-1] ---&gt; value : 2</div><div class="line">thread[Thread-2] ---&gt; value : 2</div><div class="line">thread[Thread-1] ---&gt; value : 3</div><div class="line">thread[Thread-0] ---&gt; value : 2</div><div class="line">thread[Thread-0] ---&gt; value : 3</div><div class="line">thread[Thread-2] ---&gt; value : 3</div></pre></td></tr></table></figure>
<p>上面可得出<br><strong>所产生的序号虽然共享一个实例，但是没用互相干扰，而是各自独立产生序列号，确定每个线程单独提供了一个变量副本</strong></p>
<p>源码解析<br>set<br><img src="http://img.blog.csdn.net/20170324131657111?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>1.首先通过getMap(t)得到当前相关<strong>ThreadLocalMap</strong>，将值放入map中，如果为空则重新创建Map createMap(t,value)</p>
<p>ThreadLocalMap 是线程隔离的核心，它是ThreadLocal的静态内部类，实现了键值对的设置和获取（对比Map） 存储的值，只能被当前线程读取和修改，<strong>ThreadLocal操作每个线程特有的ThreadLocalMap，从而实现了变量在不同线程中的隔离</strong><br>ThreadLocalMap的键的this对象指的就是ThreadLocal，值就是所存储的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static class ThreadLocalMap</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170324132759050?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><img src="http://img.blog.csdn.net/20170324132900490?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写代码片"></p>
<hr>
<p><img src="http://img.blog.csdn.net/20170324132931787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>ThreadLocal处理线程的局部变量，要比synchronized同步机制解决线程问题更简单，更方便，而且结果程序拥有更高的并发性</p>
</blockquote>
<h3 id="线程的异常处理"><a href="#线程的异常处理" class="headerlink" title="线程的异常处理"></a>线程的异常处理</h3><p><strong>所有异常必须在run方法进行处理，不能抛出throw exception</strong></p>
<ul>
<li>方法一：在try…catch内处理</li>
<li>方法二：实现一个UncaughtExceptionHandler接口</li>
</ul>
<p>处理unchecked异常<br><img src="http://img.blog.csdn.net/20170324133548889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>设计一个异常线程B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ThreadB implements Runnable &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		</div><div class="line">		int num = Integer.parseInt(&quot;A&quot;);</div><div class="line">		System.out.println(num);</div><div class="line">		System.out.println(&quot;This is Exception Thread B &quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理线程异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ExceptionOfThreadB implements UncaughtExceptionHandler &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void uncaughtException(Thread t, Throwable e) &#123;</div><div class="line">		</div><div class="line">		System.out.println(&quot;Thread --&gt;&quot;+t.getName()+&quot;(&quot;+t.getId()+&quot;)&quot;);</div><div class="line">	</div><div class="line">	    System.out.println(&quot;Thread Exception --&gt;&quot;+e.getClass().getName());</div><div class="line">	    </div><div class="line">	    System.out.println(&quot;exception message --&gt;&quot;+e.getMessage());</div><div class="line">	    </div><div class="line">	    System.out.println(&quot;state --&gt;&quot; + t.getState());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		ThreadB threadException = new ThreadB();</div><div class="line">		Thread t = new Thread(threadException,&quot;threadException&quot;);</div><div class="line">		//设置异常</div><div class="line">		t.setUncaughtExceptionHandler(new ExceptionOfThreadB());</div><div class="line">		t.start();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="console-2"><a href="#console-2" class="headerlink" title="console"></a>console</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread --&gt;threadException(10)</div><div class="line">Thread Exception --&gt;java.lang.NumberFormatException</div><div class="line">exception message --&gt;For input string: &quot;A&quot;</div><div class="line">state --&gt;RUNNABLE</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/线程笔记——创建线程的3种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/线程笔记——创建线程的3种方式/" itemprop="url">线程笔记——创建线程的3种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:11:27+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://img.blog.csdn.net/20170324103043780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="最直接——继承Thread类"><a href="#最直接——继承Thread类" class="headerlink" title="最直接——继承Thread类"></a>最直接——继承Thread类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ThreadA extends Thread &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(500L);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(&quot;This is Thread A From Extending Thread Class&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最常用——实现Runable接口"><a href="#最常用——实现Runable接口" class="headerlink" title="最常用——实现Runable接口"></a>最常用——实现Runable接口</h3><p>相比继承Thread类，实现Runable接口有以下优势</p>
<ul>
<li>避免 Java 的单继承特性而带来的局限；</li>
<li>增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；</li>
<li>适合多个相同程序代码的线程区处理同一资源的情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class ThreadB implements Runnable &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(1000L);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;This is Thread B From Implements Runnable &quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回值——Callable"><a href="#返回值——Callable" class="headerlink" title="返回值——Callable"></a>返回值——Callable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ThreadC implements Callable&lt;String&gt;&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String call() &#123;</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			Thread.sleep(1800L);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;This is Thread C From Implements Callable&quot;);</div><div class="line">		return &quot;Thread C&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		ThreadA a = new ThreadA();</div><div class="line">		a.start(); </div><div class="line">		</div><div class="line">		</div><div class="line">		ThreadB b = new ThreadB();</div><div class="line">		new Thread(b).start();</div><div class="line">		</div><div class="line">		</div><div class="line">		ThreadC c = new ThreadC();</div><div class="line"></div><div class="line">		FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(c);</div><div class="line">		System.out.println(&quot;This is Main Thread -----&gt; Begin&quot;);</div><div class="line">		new Thread(task).start();</div><div class="line">		try &#123;</div><div class="line">			System.out.println(&quot;result is ------&gt;&quot;+task.get());;</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (ExecutionException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;This is Main Thread -----&gt; End&quot;);</div><div class="line">		</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">This is Main Thread -----&gt; Begin</div><div class="line">This is Thread A From Extending Thread Class</div><div class="line">This is Thread B From Implements Runnable </div><div class="line">This is Thread C From Implements Callable</div><div class="line">result is ------&gt;Thread C</div><div class="line">This is Main Thread -----&gt; End</div></pre></td></tr></table></figure>
<p>线程指的是程序中的执行线程，在JavaVM种允许程序并发运行多个执行线程</p>
<p>每个线程有个优先级（高优先级执行优先于低优先级线程）</p>
<p>每个线程都可以或不可以标记为一个守护线程（后台运行的线程）</p>
<p>JavaVM启动时，最开始创建一个非守护线程（用来启动某个类指定的main方法），遇到下面情况线程才会停止执行<br>① 调用Runtime的exit()<br>② 安全管理器允许退出发生<br>③ 非守护线程全部停止执行</p>
<p><img src="http://img.blog.csdn.net/20170324103211531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Thread的构造方法"></p>
<p>线程主要方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">currentThread() //获取当前线程</div><div class="line">yield() //暂停当前线程，执行其他线程</div><div class="line">sleep() //休眠</div><div class="line">start() //启动线程</div><div class="line">run() //如果线程是Runable构造，则调用Runable种run方法，否则，该方法不执行任何操作返回</div><div class="line">interrupt() //中断线程</div><div class="line">interrupted() //测试当前线程是否已经中断</div><div class="line">getPriority() //得到优先级</div><div class="line">getName() //线程名称</div><div class="line">getId() //线程唯一标识</div><div class="line">join() //等待该线程终止</div><div class="line">setDeamon() //设置守护线程</div><div class="line">activeCount() //当前线程的线程组活动线程</div><div class="line">checkAccess()//当前运行的线程是否有权修改该线程</div><div class="line">dumpStack() //当前线程的堆栈跟踪打印导标准错误流</div><div class="line">getContextClassLoader() //返回线程上下文</div><div class="line">getStackTrace() //返回活动线程堆栈跟踪的活动线程</div><div class="line">getState() //返回该线程状态</div><div class="line">getThreadGroup() //获取线程组</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/Session跨域的几种方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/Session跨域的几种方案/" itemprop="url">Session跨域的几种方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:10:33+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/跨域/" itemprop="url" rel="index">
                    <span itemprop="name">跨域</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前项目中涉及到跨域问题（2个不同的域名访问同一个服务器）造成session丢失的问题，请求分发用的是nginx</p>
<p>总结了以下，常用的session处理方式有以下几种</p>
<h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h2><p>【概念】当对后端的多台动态应用服务器做负载均衡时，ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream myproject &#123;</div><div class="line">    ip_hash;</div><div class="line">    server 192.168.40.31:8070 //down 将服务器移除负载</div><div class="line">    server 192.168.40.16:8080; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>【缺点】使用ip_hash指令<strong>无法保证后端服务器的负载均衡</strong>，可能有些后端服务器接收的请求多，有些后端服务器收到的请求少，而且设置后端服务权重等方法将不起作用</p>
<p><a href="http://server.zzidc.com/fwqjs/222.html" target="_blank" rel="external">关于ip_hash</a></p>
<h2 id="session共享"><a href="#session共享" class="headerlink" title="session共享"></a>session共享</h2><h3 id="第三方存储"><a href="#第三方存储" class="headerlink" title="第三方存储"></a>第三方存储</h3><p>【思路】把session数据保存到内存以外的一个统一的地方，例如Memcached/Redis等数据库中。那么问题又来了，如何替换掉Servlet容器创建和管理HttpSession的实现呢？（HttpSession是通过Servlet容器创建和管理的，像Tomcat/Jetty都是保存在内存中的）</p>
<p>方法<br>1). 设计一个Filter，利用HttpServletRequestWrapper，实现自己的 getSession()方法，接管创建和管理Session数据的工作(SpringSession)</p>
<blockquote>
<p>Spring Session提供了一套创建和管理Servlet HttpSession的方案。Spring Session提供了集群Session（Clustered Sessions）功能，默认采用外置的Redis来存储Session数据，以此来解决Session共享的问题</p>
</blockquote>
<p>参考<br><a href="https://github.com/spring-projects/spring-session" target="_blank" rel="external">spring-session</a><br><a href="http://docs.spring.io/spring-session/docs/1.3.0.RELEASE/reference/html5/" target="_blank" rel="external">spring-session-官方英文文档</a><br><a href="http://blog.csdn.net/patrickyoung6625/article/details/45694157" target="_blank" rel="external">spring-session-csdn-blog</a></p>
<p>2). 利用Servlet容器提供的插件功能，自定义HttpSession的创建和管理策略，并通过配置的方式替换掉默认的策略(需要耦合Tomcat/Jetty等Servlet容器的代码)</p>
<p>参考(基于tomcat6或者7)<br><a href="https://github.com/jcoleman/tomcat-redis-session-manager" target="_blank" rel="external">tomcat-redis-manager</a><br><a href="https://github.com/magro/memcached-session-manager" target="_blank" rel="external">tomcat-memcached-manager</a></p>
<h2 id="session复制"><a href="#session复制" class="headerlink" title="session复制"></a>session复制</h2><p>与服务器有关<br>参考<br><a href="http://wiki.jikexueyuan.com/project/tomcat/clustering.html" target="_blank" rel="external">tomcat中文文档</a><br><a href="http://tomcat.apache.org/tomcat-8.0-doc/config/cluster.html" target="_blank" rel="external">tomcat官方英文文档</a></p>
<h2 id="http-无状态-token"><a href="#http-无状态-token" class="headerlink" title="http 无状态 token"></a>http 无状态 token</h2><p><a href="http://baike.baidu.com/item/HTTP%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">百度百科（什么是无状态协议）</a><br><a href="http://wiki.jikexueyuan.com/project/oauth-2/" target="_blank" rel="external">OAuth2文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【Java8】lambda表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【Java8】lambda表达式/" itemprop="url">【Java8】lambda表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:09:56+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java8/" itemprop="url" rel="index">
                    <span itemprop="name">java8</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>学习内容</p>
<ul>
<li>行为参数化</li>
<li>lambda表达式</li>
<li>方法引用</li>
</ul>
</li>
<li><p>行为参数化</p>
<ul>
<li>让函数仅保留模板代码，而把筛选条件抽离出来当做参数传递进来</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; filterApples = filterApplesByAppleFilter(apples,(Apple apple) -&gt; Color.RED.equals(apple.getColor()) &amp;&amp; apple.getWeight() &gt;= 100);</div></pre></td></tr></table></figure>
<ul>
<li>lambda表达式定义</li>
</ul>
<blockquote>
<p>lambda表达式定义为一种 简洁、可传递的匿名函数，首先我们需要明确<strong>lambda表达式本质上是一个函数，虽然它不属于某个特定的类，但具备参数列表、函数主体、返回类型，以及能够抛出异常；其次它是匿名的，lambda表达式没有具体的函数名称</strong>；lambda表达式可以像参数一样进行传递，从而极大的简化代码的编写</p>
</blockquote>
<ul>
<li>lambda表达式格式<ul>
<li>格式一： 参数列表 -&gt; 表达式</li>
<li>格式二： 参数列表 -&gt; {表达式集合}</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>lambda表达式隐含了return关键字</strong>，所以在单个的表达式中，我们无需显式的写return关键字，但是<strong>当表达式是一个语句集合的时候，则需要显式添加return，并用花括号{ }将多个表达式包围起来</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//返回给定字符串的长度，隐含return语句</div><div class="line">(String s) -&gt; s.length() </div><div class="line"></div><div class="line">// 始终返回42的无参方法</div><div class="line">() -&gt; 42 </div><div class="line"></div><div class="line">// 包含多行表达式，则用花括号括起来</div><div class="line">(int x, int y) -&gt; &#123;</div><div class="line">    int z = x * y;</div><div class="line">    return x + z;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>依托于函数式接口使用lambda表达式</p>
<ul>
<li>自定义函数式接口<ul>
<li>函数式接口定义为只具备 一个抽象方法的接口</li>
</ul>
</li>
</ul>
</li>
<li><p>方法引用</p>
</li>
</ul>
<p>静态方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">(args) -&gt; ClassName.staticMethod(args) / ClassName::staticMethod</div></pre></td></tr></table></figure>
<p> 参数的实例方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(args) -&gt; args.instanceMethod() / ClassName::instanceMethod //ClassName是args的类型</div></pre></td></tr></table></figure>
<p>外部的实例方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(args) -&gt; ext.instanceMethod(args) / ext::instanceMethod(args)</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【Java8】foreach/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【Java8】foreach/" itemprop="url">【Java8】foreach</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:06:43+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java8/" itemprop="url" rel="index">
                    <span itemprop="name">java8</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="map-foreach"><a href="#map-foreach" class="headerlink" title="map foreach"></a>map foreach</h3><p>以前的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (Map.Entry&lt;String, String&gt; map : paramsMap.entrySet()) &#123;</div><div class="line">params.add(new BasicNameValuePair(map.getKey(), map.getValue()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>java8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">paramsMap.forEach((key,value) -&gt; params.add(new BasicNameValuePair(key,value)));</div></pre></td></tr></table></figure>
<h3 id="List-foreach"><a href="#List-foreach" class="headerlink" title="List foreach"></a>List foreach</h3><p>以前方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (String item:arrayList)&#123;</div><div class="line">    System.out.println(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>java8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">list.forEach(item-&gt;System.out.println(item));</div><div class="line"></div><div class="line">list.forEach(System.out::println);</div><div class="line"></div><div class="line">list.forEach(item-&gt;&#123;</div><div class="line">    if(&quot;zhangshan&quot;.equals(item))&#123;</div><div class="line">        System.out.println(item);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">list.stream()</div><div class="line">        .filter(s-&gt; s.contains(&quot;li&quot;)||s.contains(&quot;si&quot;))</div><div class="line">        .forEach(System.out::println);</div><div class="line"></div><div class="line">list.stream()</div><div class="line">        .filter(s-&gt;s.contains(&quot;E&quot;))</div><div class="line">        .findFirst().ifPresent(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>
<hr>
<p>【例1】select d.name from dish d where d.price &gt; 20<br> java8之前的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;DishInfo&gt; dishes = new ArrayList&lt;DishInfo&gt;();</div><div class="line">for(DishInfo dish : dishes)&#123;</div><div class="line">	if(dish.getPrice() &gt; 20)&#123;</div><div class="line">		dishes.add(dish);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>java8</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">List&lt;DishInfo&gt; dishes = Lists.newArrayList(</div><div class="line">new DishInfo(&quot;chiken&quot;, (float) 10.0,DishInfo.Type.OTHER),</div><div class="line">new DishInfo(&quot;beef&quot;,(float) 25.0,DishInfo.Type.BEAF)</div><div class="line">);</div><div class="line">		</div><div class="line">List&lt;String&gt; dishNames = </div><div class="line">             dishes.stream()</div><div class="line">           //dishes.parallelStream() //并行处理</div><div class="line">				   .filter(dish -&gt; dish.getPrice() &gt; 20)			                      </div><div class="line">                   .sorted(comparing(DishInfo::getType))</div><div class="line">                   .map(DishInfo::getName)	</div><div class="line">                   .limit(3)			                        </div><div class="line">				   .collect(toList());</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//.count()</div><div class="line">//.distinct()</div><div class="line">//.skip(2)</div><div class="line">//.map(String::length)</div><div class="line">//.flatMap()</div><div class="line">//.reduce()</div><div class="line">Stream.iterate()</div><div class="line">Stream.generate(Math::random).limit(6).forEach(System.out::println);</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; title = Arrays.asList(&quot;java&quot;,&quot;python&quot;,&quot;javascript&quot;);</div><div class="line">	    Stream&lt;String&gt; streamTitle = title.stream();</div><div class="line">	    streamTitle.forEach(System.out::println);</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/线程笔记——内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/线程笔记——内存模型/" itemprop="url">线程笔记——内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:06:01+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="happen-before-规则"><a href="#happen-before-规则" class="headerlink" title="happen-before 规则"></a>happen-before 规则</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p><strong>如果操作 A 先行发生于操作 B，在发生操作 B 之前，操作A产生的影响都能被操作 B 观察到。</strong>影响包括修改了内存中共享变量的值、发送了消息、调用了方法等</p>
</blockquote>
<hr>
<blockquote>
<p><strong>它与时间上的先后发生基本没有太大关系。它是判断数据是否存在竞争、线程是否安全的主要依据</strong></p>
</blockquote>
<p>###八条可保证 happen—before 的规则</p>
<blockquote>
<p>它们无需任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随机地重排序</p>
</blockquote>
<ol>
<li><p><strong>程序次序规则</strong>：在一个单独的线程中，<strong>按照程序代码的执行流顺序</strong>，（时间上）先执行的操作 happen—before（时间上）后执行的操作。</p>
</li>
<li><p><strong>管理锁定规则</strong>：一个 unlock 操作 happen—before 后面对同一个锁的 lock 操作。</p>
</li>
<li><p><strong>volatile变量规则</strong>：对一个 volatile 变量的<strong>写操作</strong> happen—before 后面对该变量的<strong>读操作</strong>。</p>
</li>
<li><p><strong>线程启动规则</strong>：Thread 对象的 <strong>start()方法</strong> happen—before 此线程的每一个动作。</p>
</li>
<li><p><strong>线程终止规则</strong>：线程的所有操作都 happen—before 对此线程的终止检测，可以通过 Thread.join()方法结束。 Thread.isAlive()的返回值等手段检测到线程已经终止执行。</p>
</li>
<li><p><strong>线程中断规则</strong>：对线程 interrupt()方法的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。</p>
</li>
<li><p><strong>对象终结规则</strong>：一个对象的初始化完成（构造函数执行结束）happen—before 它的 finalize()方法的开始。</p>
</li>
<li><p><strong>传递性</strong>：如果操作 A happen—before 操作 B，操作 B happen—before 操作 C，那么可以得出 A happen—before 操作 C。</p>
</li>
</ol>
<p>【问题一】假设存在如下三个线程，分别执行对应的操作：线程 A 中执行如下操作：i=1，线程 B 中执行如下操作：j=i，线程 C 中执行如下操作：i=2。并且保持A与B之间的happen—before关系。同时C出现在A和B操作之间。C和B没有happen-before关系。线程B是否是线程安全的？<br>【回答】 <strong>由于C 与 B 并没有 happen—before 关系，j的值不确定，线程 C 对变量 i 的影响可能会被线程 B 观察到，也可能不会，这时线程 B 就存在读取到不是最新数据的风险</strong>，B不具备线程安全性</p>
<p>【问题二】假设存在线程 A 和线程 B，线程 A 先（时间上）调用了 setValue(3)操作，然后（时间上）线程B调用了同一对象的 getValue()方法，那么线程B得到的返回值一定是3吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private int value = 0;  </div><div class="line"></div><div class="line">public int get()&#123;  </div><div class="line">    return value;  </div><div class="line">&#125;  </div><div class="line">public void set(int value)&#123;  </div><div class="line">    this.value = value;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>【回答】上面八条原则不适用于该value变量。从而我们可以判定线程 A 中的 setValue(3)操作与线程 B 中的 getValue()操作不存在 happen—before 关系。因此，尽管线程 A 的 setValue(3)在操作时间上先于操作 B 的 getvalue()，但无法保证线程 B 的 getValue()操作一定观察到了线程 A 的 setValue(3)操作所产生的结果，也即是 getValue()的返回值不一定为 3</p>
<blockquote>
<p><strong>因此，”一个操作时间上先发生于另一个操作“并不代表”一个操作 happen—before 另一个操作”。</strong></p>
</blockquote>
<p>解决方案： 可以将 setValue（int）方法和 getValue()方法均定义为 synchronized 方法，也可以把 value 定义为 volatile 变量</p>
<p>【问题三】 假设同一个线程执行上面两个操作：操作 A：x=1 和操作 B：y=2。从第一条规则判定操作Ahappen—before操作B。是否意味着操作 A 在时间上先与操作 B 发生？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = 1；  </div><div class="line">y = 2;</div></pre></td></tr></table></figure></p>
<p>【回答】由于编译器的指令重排序等原因，操作 A 在时间上有可能后于操作 B 被处理器执行，但这并不影响 happen—before 原则的正确性</p>
<blockquote>
<p><strong>因此，”一个操作 happen—before 另一个操作“并不代表”一个操作时间上先发生于另一个操作”。</strong></p>
</blockquote>
<p>重排序：Java 语言规范规定了 JVM 线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致。这个过程通过叫做指令的重排序。指令重排序存在的意义在于：JVM 能够根据处理器的特性（CPU 的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合 CPU 的执行特点，最大限度的发挥机器的性能。在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>一个操作和另一个操作必定存在某个顺序，要么一个操作或者是先于或者是后于另一个操作，或者与两个操作同时发生。同时发生是完全可能存在的，特别是在多 CPU 的情况下。而两个操作之间却可能没有 happen-before 关系，也就是说有可能发生这样的情况，操作 A 不 happen-before 操作 B，操作 B 也不 happen-before 操作 A，用数学上的术语 happen-before 关系是个偏序关系。两个存在 happen-before 关系的操作不可能同时发生，一个操作 A happen-before 操作 B，它们必定在时间上是完全错开的，这实际上也是同步的语义之一（独占访问）</p>
</blockquote>
<h3 id="利用-happen—before-规则分析-DCL-双重检查加锁"><a href="#利用-happen—before-规则分析-DCL-双重检查加锁" class="headerlink" title="利用 happen—before 规则分析 DCL(双重检查加锁)"></a>利用 happen—before 规则分析 DCL(双重检查加锁)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class LazySingleton &#123;  </div><div class="line">    private int someField;  </div><div class="line"></div><div class="line">    private static LazySingleton instance;  </div><div class="line"></div><div class="line">    private LazySingleton() &#123;  </div><div class="line">        this.someField = new Random().nextInt(200)+1;         // (1)  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public static LazySingleton getInstance() &#123;  </div><div class="line">        if (instance == null) &#123;                               // (2)  </div><div class="line">            synchronized(LazySingleton.class) &#123;               // (3)  </div><div class="line">                if (instance == null) &#123;                       // (4)  </div><div class="line">                    instance = new LazySingleton();           // (5)  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return instance;                                      // (6)  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public int getSomeField() &#123;  </div><div class="line">        return this.someField;                                // (7)  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里得到单一的 instance 实例是没有问题的，问题的关键在于尽管得到了 Singleton 的正确引用，但是却有可能访问到其成员变量的不正确值。具体来说 Singleton.getInstance().getSomeField() 有可能返回 someField 的默认值 0。</p>
<p>如果程序行为正确的话，这应当是不可能发生的事，因为在构造函数里设置的 someField 的值不可能为 0。为也说明这种情况理论上有可能发生，我们只需要说明语句(1)和语句(7)并不存在 happen-before 关系</p>
<p>【解释】假设线程Ⅰ是初次调用 getInstance()方法，紧接着线程Ⅱ也调用了 getInstance()方法和 getSomeField()方法，我们要说明的是线程Ⅰ的语句(1)并不 happen-before 线程Ⅱ的语句(7)。线程Ⅱ在执行 getInstance()方法的语句(2)时，由于对 instance 的访问并没有处于同步块中，因此线程Ⅱ可能观察到也可能观察不到线程Ⅰ在语句(5)时对 instance 的写入，也就是说 instance 的值可能为空也可能为非空。我们先假设 instance 的值非空，也就观察到了线程Ⅰ对 instance 的写入，这时线程Ⅱ就会执行语句(6)直接返回这个 instance 的值，然后对这个 instance 调用 getSomeField()方法，该方法也是在没有任何同步情况被调用，因此整个线程Ⅱ的操作都是在没有同步的情况下调用 ，这时我们便无法利用上述 8 条 happen-before 规则得到线程Ⅰ的操作和线程Ⅱ的操作之间的任何有效的 happen-before 关系</p>
<p>主要考虑规则的第 2 条，<strong>由于线程Ⅱ没有在进入 synchronized 块，因此不存在 lock 与 unlock 锁的问题），这说明线程Ⅰ的语句(1)和线程Ⅱ的语句(7)之间并不存在 happen-before 关系，这就意味着线程Ⅱ在执行语句(7)完全有可能观测不到线程Ⅰ在语句(1)处对 someFiled 写入的值，这就是 DCL 的问题所在</strong></p>
<p>对 DCL 的分析也告诉我们一条经验原则：<strong>对引用（包括对象引用和数组引用）的非同步访问，即使得到该引用的最新值，却并不能保证也能得到其成员变量（对数组而言就是每个数组元素）的最新值。</strong></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最简单而且安全的解决方法是使用 static 内部类的思想，它利用的思想是：<strong>一个类直到被使用时才被初始化，而类初始化的过程是非并行的，这些都有 JLS 保证。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line"></div><div class="line">  private Singleton() &#123;&#125;  </div><div class="line"></div><div class="line">  // Lazy initialization holder class idiom for static fields  </div><div class="line">  private static class InstanceHolder &#123;  </div><div class="line">   private static final Singleton instance = new Singleton();  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  public static Singleton getSingleton() &#123;   </div><div class="line">    return InstanceHolder.instance;   </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>可以将 instance 声明为 volatile，即<br> private volatile static LazySingleton instance;</li>
</ol>
<p>线程Ⅰ的语句(5) -&gt; 语线程Ⅱ的句(2)，根据单线程规则，线程Ⅰ的语句(1) -&gt; 线程Ⅰ的语句(5)和语线程Ⅱ的句(2) -&gt; 语线程Ⅱ的句(7)，再根据传递规则就有线程Ⅰ的语句(1) -&gt; 语线程Ⅱ的句(7)，这表示线程Ⅱ能够观察到线程Ⅰ在语句(1)时对 someFiled 的写入值，程序能够得到正确的行为</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><blockquote>
<p><strong>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</strong>(主要是指共享变量，存在竞争问题的变量)</p>
</blockquote>
<hr>
<blockquote>
<p>Java 内存模型规定所有的变量都存储在主内存中，而每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。<strong>不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来完成。</strong></p>
</blockquote>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><h4 id="内存与工作内存之间交互的实现细节"><a href="#内存与工作内存之间交互的实现细节" class="headerlink" title="内存与工作内存之间交互的实现细节"></a>内存与工作内存之间交互的实现细节</h4><ol>
<li><p><strong>luck（锁定）</strong>：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。</p>
</li>
<li><p><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</li>
<li><p><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的 load 动作使用。</p>
</li>
<li><p><strong>load（载入）</strong>：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
<li><p><strong>use（使用）</strong>：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时将会执行这个操作。</p>
</li>
<li><p><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中，以便随后的 write 操作使用。</p>
</li>
<li><p><strong>write（写入）</strong>：作用于主内存的变量，它把 store 操作从工作内存中得到的变量值放入主内存的变量中。</p>
</li>
</ol>
<h4 id="Java-内存模型还规定了执行上述-8-种基本操作时必须满足如下规则"><a href="#Java-内存模型还规定了执行上述-8-种基本操作时必须满足如下规则" class="headerlink" title="Java 内存模型还规定了执行上述 8 种基本操作时必须满足如下规则"></a>Java 内存模型还规定了执行上述 8 种基本操作时必须满足如下规则</h4><ul>
<li><p>不允许 read 和 load、store 和 write 操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read 与 load 之间、store 与 write 之间是可插入其他指令的。</p>
</li>
<li><p>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
</li>
<li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</p>
</li>
<li><p>一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p>
</li>
<li><p>一个变量在同一个时刻只允许一条线程对其执行 lock 操作，但 lock 操作可以被同一个条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</p>
</li>
<li><p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</p>
</li>
<li><p>如果一个变量实现没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。</p>
</li>
<li><p>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存（执行 store 和 write 操作）。</p>
</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><blockquote>
<p>final 类型的域是不能修改的，除了这一点外，在 Java 内存模型中，final 域还有着特殊的语义，<strong>final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</strong></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/【热部署】JRebel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/【热部署】JRebel/" itemprop="url">【热部署】JRebel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:04:48+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/热部署/" itemprop="url" rel="index">
                    <span itemprop="name">热部署</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://zeroturnaround.com/software/jrebel/quickstart/eclipse/" target="_blank" rel="external">官方文档</a></p>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p><strong>1. Eclipse &gt; Help &gt; Install New Software &gt; Add</strong></p>
<blockquote>
<p>name : JRebel<br>location：<a href="http://update.zeroturnaround.com/update-site" target="_blank" rel="external">http://update.zeroturnaround.com/update-site</a></p>
</blockquote>
<h3 id="Active"><a href="#Active" class="headerlink" title="Active"></a>Active</h3><p><strong>2.1、Help &gt; JRebel &gt; Activation</strong><br><strong>2.2、Fill out the form</strong><br><strong>2.3、Activate JRebel</strong><br><strong>2.4、Next → Startup configuration</strong></p>
<h3 id="Startup-Configuration"><a href="#Startup-Configuration" class="headerlink" title="Startup Configuration"></a>Startup Configuration</h3><blockquote>
<p>将JRebel部署到服务器中或者在独立应用中</p>
</blockquote>
<h3 id="Project-configuration"><a href="#Project-configuration" class="headerlink" title="Project configuration"></a>Project configuration</h3><blockquote>
<p>配置项目</p>
</blockquote>
<p><strong>3.1、Help &gt; JRebel &gt; Configuration &gt; Projects.</strong><br><img src="https://zeroturnaround.com/wp-content/uploads/2014/10/jrebel-ide-icon.png" alt="这里写图片描述">This will generate rebel.xml and keep it up to date</p>
<p><img src="https://zeroturnaround.com/wp-content/uploads/2016/02/jrcloud.png" alt="这里写图片描述">This will generate rebel-remote.xml</p>
<p><strong>重新部署应用</strong></p>
<p><img src="http://img.blog.csdn.net/20170330154533605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><img src="http://img.blog.csdn.net/20170330154543168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><img src="http://img.blog.csdn.net/20170330154553668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA1OTc0Nzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/Zookeeper学习笔记（四）——-主从模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/Zookeeper学习笔记（四）——-主从模式/" itemprop="url">Zookeeper学习笔记（四）—— 主从模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T11:02:01+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">Zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="zookeeper编程"><a href="#zookeeper编程" class="headerlink" title="zookeeper编程"></a>zookeeper编程</h3><ul>
<li>zookeeper有一个java绑定和一个c绑定</li>
<li>c绑定的两种形式：单线程和多线程</li>
<li>两种形式的区别在于<strong>如何循环消息以获取更多消息</strong></li>
</ul>
<h3 id="主从复制的Zookeeper"><a href="#主从复制的Zookeeper" class="headerlink" title="主从复制的Zookeeper"></a>主从复制的Zookeeper</h3><p>在评估、开发和测试环境中。使用zookeeper独立模式</p>
<p>在生产模式中。应用主从复制模式。</p>
<blockquote>
<p>相同应用中服务器主从复制组叫做 quorum , 并且在主从复制模式中，在quorum中的所有服务器有相同的配置文件副本</p>
</blockquote>
<p>注意：<strong>如果使用zk的主从模式，至少3台服务器。并且建议基数服务器。</strong><br>原因：1. 如果只有两台服务器，其中的一个故障的时候，没有足够的机器形成多数quorum。</p>
<ol>
<li>在本质上两台服务比单台服务更不稳定，因为有两个单点。</li>
</ol>
<p>配置文件修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tickTime=2000</div><div class="line">dataDir=/var/lib/zookeeper</div><div class="line">clientPort=2181</div><div class="line">initLimit=5 </div><div class="line">syncLimit=2</div><div class="line">server.1=zoo1:2888:3888</div><div class="line">server.2=zoo2:2888:3888</div><div class="line">server.3=zoo3:2888:3888</div></pre></td></tr></table></figure>
<ul>
<li>initLimit: 限定quorum中的Zookeeper服务器连接到Leader的超时时间。（eg.initLimit的超时时间是5个标记号，2000毫秒一个标记，就是10秒） </li>
<li>server.x: 列出了构成Zookeeper服务的服务器(eg.通过查找data目录中的myid文件知道是哪个服务。这个myid个文件包含了服务编号，用ASCII)</li>
<li>端口号2888和3888：服务器节点使用前面的端口连接到其他节点。便于同事之间的通信（eg.对更新的顺序取得统一的意见）<blockquote>
<p>一个Zookeeper的服务器用这个端口连接follower到leader。当一个新的leader产生时，follower使用这个端口打开一个TCP连接，连接到leader。因为默认的leader选举也使用TCP。我们现在需要另一个端口用来leader选举。这是在服务器条目的第二个端口</p>
</blockquote>
</li>
</ul>
<hr>
<p>注意：在一台机器上测试多台服务器，在服务器配置文件为每个server.x指定servername为localhost,和独有的quorum &amp; leader选举端口（也就是 2888:3888, 2889:3889, 2890:3890在上面的示例中）。当然分开dataDir和不同的clientPort也是非常重要的</p>
<hr>
<p>优化：获取更新的低延迟，有一个专门的事务日志目录非常重要。默认情况下，事务日志作为一个数据快照和myid文件放入同一个目录。datalogDir参数指示一个不同的目录用于事务日志</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/Zookeeper学习笔记（一）——-基础概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/Zookeeper学习笔记（一）——-基础概念/" itemprop="url">Zookeeper学习笔记（一）—— 基础概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T10:47:11+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">Zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="zookeeper-核心"><a href="#zookeeper-核心" class="headerlink" title="zookeeper 核心"></a>zookeeper 核心</h2><ul>
<li>Zookeeper数据模型</li>
<li>Zookeeper会话</li>
<li>Zookeeper Watches</li>
<li>一致性保证（分布式事务涉及）</li>
</ul>
<hr>
<h2 id="zookeeper-数据模型"><a href="#zookeeper-数据模型" class="headerlink" title="zookeeper 数据模型"></a>zookeeper 数据模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>是zk的分层的命名空间。类似分布式文件系统。命名空间的每个节点既可以关联数据，又可以关联目录。并且路径节点总是通过斜线”/“分隔</p>
<h3 id="znodes"><a href="#znodes" class="headerlink" title="znodes"></a>znodes</h3><p>概念<br>zk中的每个节点都被称为znode。<br>znode维护一个stat结构（包括数据变化的版本号、访问控制列表变化和时间戳）</p>
</blockquote>
<p>作用</p>
<blockquote>
<p>版本号和时间戳可以让zk验证缓存和协调更新。znode的数据只要发生了变化，版本号就会增加。<br>当客户端执行更新或删除时，客户端必须提供他正在改变的znode的版本号。如果它提供的版本号和真实的数据版本号不一致，更新将会失败（行为可能被覆盖）</p>
</blockquote>
<p><strong>对zk进行编程主要是对znode作为主体操作</strong></p>
<p>关于node的扩展</p>
<blockquote>
<p>在分布式应用工程中，node可以指的是一般的主机，一个服务器，全体成员的一员，一个客户端程序，等等。在Zookeeper的文档中，znode指的是数据节点。Servers指的是组成Zookeeper服务的机器；quorum peers 指的是组成全体的servers；client指的是任何使用Zookeeper服务的主机和程序。</p>
</blockquote>
<hr>
<h2 id="znode-基本特征"><a href="#znode-基本特征" class="headerlink" title="znode 基本特征"></a>znode 基本特征</h2><h3 id="watches"><a href="#watches" class="headerlink" title="watches"></a>watches</h3><blockquote>
<p>znode的变化将会触发watches后清除watches。<strong>触发watches时，Zookeeper向客户端发送一个通知</strong></p>
<h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><ol>
<li>命名空间里的每个znodes上的数据存储都是<strong>原子性的读取和写入</strong>。</li>
<li>读取时获取所有与znode有关的数据字节，写入时替换所有的数据字节。</li>
<li>每个节点通过访问控制列表进行限制访问</li>
<li>zk不用来存储数据，只是用来<strong>管理协调数据</strong>。数据形式可以是配置表单，状态信息，集合点等</li>
<li>各种形式的协调数据属性都非常小</li>
<li>如果需要大数据存储，通常的做法是将数据存储进大存储器系统，如NFS和HDFS，然后将<strong>存储指针和地址</strong>存储进Zookeeper<h3 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h3>znode一旦session创建就存在，session结束就被删除<br><strong>临时节点不可以有子节点</strong><h3 id="序列节点"><a href="#序列节点" class="headerlink" title="序列节点"></a>序列节点</h3></li>
<li>当创建znode的时候你还可以请求在路径的最后追加一个单调递增的计数器</li>
<li>计数器在父节点命名唯一。而且是int类型。</li>
</ol>
</blockquote>
<hr>
<h2 id="zookeeper-计时"><a href="#zookeeper-计时" class="headerlink" title="zookeeper 计时"></a>zookeeper 计时</h2><h3 id="Zxid（事务ID）"><a href="#Zxid（事务ID）" class="headerlink" title="Zxid（事务ID）"></a>Zxid（事务ID）</h3><blockquote>
<p><strong>每个zk状态的变化都以zxid的形式接收到标记</strong><br>zx特征：如果zxid1早于zxid2则zxid1一定小于zxid2。并且暴露zk所有变化的总排序</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p><strong>节点的每个变化都会引起那个节点的版本号的其中之一增加</strong><br>1.version： 数据变化版本号<br>2.cversion：子目录变化版本号<br>3.aversion：访问控制列表的变化版本号</p>
<h3 id="Ticks"><a href="#Ticks" class="headerlink" title="Ticks"></a>Ticks</h3><ol>
<li>服务器使用ticks定义事件（如状态上传，会话超时，同事之间的连接超时等）的时间。通常在多服务器中使用</li>
<li>如果一个客户端请求会话超时小于最小的会话超时，服务器就会告诉客户端会话超时实际上是最低会话超时时间。<h3 id="Real-Time"><a href="#Real-Time" class="headerlink" title="Real Time"></a>Real Time</h3>zk不使用实时或时钟时间，除了将时间戳加在znode创建和更新的stat结构上。</li>
</ol>
</blockquote>
<hr>
<h2 id="zookeeper-Stat"><a href="#zookeeper-Stat" class="headerlink" title="zookeeper Stat"></a>zookeeper Stat</h2><ul>
<li>czxid - 引起这个znode创建的zxid</li>
<li>mzxid - znode最后更新的zxid</li>
<li>ctime - znode被创建的毫秒数(从1970年开始)</li>
<li>mtime - znode最后修改的毫秒数(从1970年开始)</li>
<li>version - znode数据变化号</li>
<li>cversion - znode子节点变化号</li>
<li>aversion - znode访问控制列表的变化号</li>
<li>ephemeralOwner - 如果是临时节点这个是znode拥有者的session - id。如果不是临时节点则是0。</li>
<li>dataLength - znode的数据长度</li>
<li>numChildren - znode子节点数量</li>
</ul>
<hr>
<h3 id="zookeeper-会话"><a href="#zookeeper-会话" class="headerlink" title="zookeeper 会话"></a>zookeeper 会话</h3><blockquote>
<p>Zookeeper客户端通过使用语言绑定在服务上创建一个handle建立一个和Zookeeper服务的会话</p>
</blockquote>
<p>会话成功：handle连接zk服务器。从connection变为connected状态。<br>会话失败：handle变为closed状态(例如会话超时或授权失败，或应用明确的关闭处理器)</p>
<p>创建客户端会话<br><strong>以逗号分隔开的host:port的列表</strong><br>（eg:”127.0.0.1:4545” or   “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002”)</p>
<p>zk会选择任意一个服务并尝试连接它。如果这个连接失败，客户端变为disconected，客户端会自动的尝试连接列表里的下一个服务器，直到建立连接</p>
<p>connectionString+<strong>chroot</strong>：改变程序执行时所参考的根目录位置<br><a href="http://blog.csdn.net/frozen_fish/article/details/2244870" target="_blank" rel="external">chroot命令的作用</a></p>
<p>客户端连接zk会话，作为安全措施，需要将sessionId（64位的数字）和密码发送给客户端</p>
<p>当客户端从ZK集群分隔。它将开始搜索在session创建期间指定的服务器列表server.x 。session状态将会从”connected”转为”expired”(重建超时)</p>
<p>zk客户端会自动重连，只有当zk通知session超时才能创建新的session。</p>
<p>zk集群管理session会话</p>
<blockquote>
<p>timeout决定会话何时过期。<br>当集群在指定的session超时周期内没有听到客户端(没有心跳)时发生。<br>集群会删除全部session的临时节点并立即通知其他客户端(watch这些znode的客户端)。</p>
</blockquote>
<p>过期会话状态转化实例通过watcher查看</p>
<ol>
<li>‘connected’：建立session且正在和集群通信</li>
<li>…客户端从集群分离</li>
<li>‘disconnected’：客户端丢失集群的连接</li>
<li>…时间消失，’timeout’周期之后集群过期session，客户端什么都看不到</li>
<li>…时间消失，客户端收复集群的连通性</li>
<li>‘expired’：最终客户端重连到集群，然后是过期通知</li>
</ol>
<hr>
<h2 id="zookeeper-Watches"><a href="#zookeeper-Watches" class="headerlink" title="zookeeper Watches"></a>zookeeper Watches</h2><blockquote>
<p>Zookeeper里的所有读取操作都有设置watch的选项 。<strong>watch事件是one-time触发，向客户端发送设置watch，当设置watch的数据变化时发生</strong></p>
</blockquote>
<p>watch特征</p>
<ul>
<li>一次触发</li>
<li>发往客户端</li>
<li>为数据设置watch</li>
</ul>
<h3 id="Watch特征"><a href="#Watch特征" class="headerlink" title="Watch特征"></a>Watch特征</h3><ul>
<li>Watches和其他事件、watches和异步恢复都是有序的。Zookeeper客户端保证每件事都是有序派发。</li>
<li>客户端在看到新数据之前先看到watch事件。</li>
<li>对应更新顺序的Zookeeper watches事件顺序由Zookeeper服务所见。</li>
</ul>
<p>注意：</p>
<ol>
<li>如果你得到一个watch事件且想在将来的变化得到通知，必须设置另一个watch</li>
<li>因为watches是一次触发且在获得事件和发送请求得到wathes之间有延迟你不能可靠的看到发生在Zookeeper节点的每一个变化</li>
<li>一个watch对象，或function/context对，对于指定的通知只能触发一次。(eg. 如果相同的文件通过exists和getData注册了相同的watch对象并且文件稍后删除了，watch将只会触发文件的删除通知)</li>
<li>从服务端断开连接时(比如服务器故障)，将不会得到任何watches直到重新建立连接</li>
</ol>
<hr>
<h2 id="zookeeper-ACLs"><a href="#zookeeper-ACLs" class="headerlink" title="zookeeper ACLs"></a>zookeeper ACLs</h2><blockquote>
<ol>
<li>Zookeeper使用ACLs控制访问它的znodes(Zookeeper的数据节点)</li>
<li>Zookeeper节点不由三个标准范围(用户，组 和 world)限制。Zookeeper没有znode所有者的概念。而是一个ACLs指定一组ids和与这些ids相关联的权限</li>
<li>ACL只适用于特定的znode。尤其不适用于children</li>
<li>ACLs不是递归控制<br>(eg. 如果/app对ip:192.168.1.56是只读的并且/app/status是全都可读的，任何人可以读取/app/status)</li>
<li>Zookeeper支持可插拔的权限认证方案</li>
</ol>
</blockquote>
<h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><ul>
<li>CREATE：可以创建子节点</li>
<li>READ：可以从节点获取数据并列出它的子节点</li>
<li>WRITE：可以向节点设置数据</li>
<li>DELETE：可以删除一个子节点</li>
<li>ADMIN：可以设置权限</li>
</ul>
<h3 id="内嵌的ACL-schemes"><a href="#内嵌的ACL-schemes" class="headerlink" title="内嵌的ACL schemes"></a>内嵌的ACL schemes</h3><ul>
<li>world：有单独的id，anyone,代表任何人</li>
<li>auth:不适用任何id，代表任何授权的用户。</li>
<li>digest：使用username;password字符串生成MD5哈希作为ACL ID身份。通过发送username:password明文授权。在ACL里使用时expression将会是username:base64编码的SHA1 password摘要。</li>
<li>ip:使用客户端IP作为ACL ID身份。</li>
</ul>
<h2 id="一致性保证"><a href="#一致性保证" class="headerlink" title="一致性保证"></a>一致性保证</h2><p><strong>顺序一致性</strong></p>
<blockquote>
<p>客户端的更新将发送到序列</p>
</blockquote>
<p><strong>原子性</strong></p>
<blockquote>
<p>更新成功或失败 – 没有局部结果</p>
</blockquote>
<p><strong>单一系统影像</strong></p>
<blockquote>
<p>客户端看到的服务端的视图都一样</p>
</blockquote>
<p><strong>可靠性</strong></p>
<p>一旦更新应用了，它将会一直保持到下次更新覆盖。这个保证有两个推论</p>
<ul>
<li><p>如果客户端成功，更新就被应用。客户端看不到失败现象。<br>客户端可以看到任何更新，通过读取请求或成功的更新<br>时效性</p>
</li>
<li><p>系统的客户端视图在特定的时间保证是最新的。</p>
</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><blockquote>
<p>创建Zookeeper的时候，同时创建了两个线程：一个IO线程和事件线程。所有的IO都在在IO线程上(使用Java NIO)。所有的事件回调都在事件线程上。Session在IO线程上维护如重连Zookeeper服务和维护心跳。同步方法调用也在IO线程处理。所有异步调用和watche事件在事件线程上处理</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg"
               alt="dzx" />
          <p class="site-author-name" itemprop="name">dzx</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">144</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">57</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">109</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dzx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
