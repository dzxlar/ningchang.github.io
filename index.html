<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="dzxblog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="dzxblog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dzxblog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>dzxblog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">dzxblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/08/Python小试牛刀——获取代理IP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/Python小试牛刀——获取代理IP/" itemprop="url">Python小试牛刀——获取代理IP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T17:40:46+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>因为爬某些网站有IP限制，所以弄了一个获取代理的工具类</p>
</blockquote>
<pre><code># -*- coding: utf-8 -*-

from bs4 import BeautifulSoup # pip install bs4 安装lxml解析器 import pip print(pip.pep425tags.get_supported()) 检测版本https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml
import requests
import random

class Proxy:

    def getIps(self,url, headers):
        response = requests.get(url, headers=headers)
        soup = BeautifulSoup(response.text, &apos;lxml&apos;)
        ips = soup.find_all(&apos;tr&apos;)
        ipList = []
        for i in range(1, len(ips)):
            ipInfo = ips[i]
            tds = ipInfo.find_all(&apos;td&apos;)
            ipList.append(tds[1].text + &apos;:&apos; + tds[2].text)
        return ipList

    def getRandomIp(self,ipList):
        proxyList = []
        for ip in ipList:
            proxyList.append(&apos;http://&apos; + ip)
        proxyIp = random.choice(proxyList)
        proxyUrl = {&apos;http&apos;: proxyIp,&apos;https&apos;:proxyIp}
        return proxyUrl

if __name__ == &apos;__main__&apos;:

    proxy = Proxy()

    url = &apos;http://www.xicidaili.com/nn/&apos;
    headers = {
        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&apos;
    }
    ipList = proxy.getIps(url, headers=headers)
    proxyUrl = proxy.getRandomIp(ipList)
    print(proxyUrl)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/02/Python小试牛刀——新浪微博自动转发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/Python小试牛刀——新浪微博自动转发/" itemprop="url">Python小试牛刀——新浪微博自动转发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T16:29:57+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>为了更加熟练python，所以通过新浪微博转发的例子加深印象</p>
</blockquote>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>python3.6</li>
</ul>
<h2 id="登录实现"><a href="#登录实现" class="headerlink" title="登录实现"></a>登录实现</h2><h3 id="登录请求链"><a href="#登录请求链" class="headerlink" title="登录请求链"></a>登录请求链</h3><p>通过火狐追踪新浪微博完整登录请求，可以获得2个关键URL</p>
<ul>
<li>对登录进行加密处理<ul>
<li>preLoginUrl = ‘<a href="https://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=%s&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)&amp;_=%s" target="_blank" rel="external">https://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=%s&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)&amp;_=%s</a>‘ % (su,int(round(time.time() * 1000))) </li>
</ul>
</li>
<li>核心登录地址<ul>
<li>loginUrl = ‘<a href="https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19" target="_blank" rel="external">https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19</a>)’</li>
</ul>
</li>
</ul>
<blockquote>
<p> 可以通过 <a href="http://login.sina.com.cn/js/sso/ssologin.js" target="_blank" rel="external">http://login.sina.com.cn/js/sso/ssologin.js</a> 解压查看加密方式</p>
</blockquote>
<h3 id="通过preLoginUrl得到几个关键参数"><a href="#通过preLoginUrl得到几个关键参数" class="headerlink" title="通过preLoginUrl得到几个关键参数"></a>通过preLoginUrl得到几个关键参数</h3><p><strong>servertime,nonce,pubkey,rsakv</strong></p>
<h3 id="用户名通过base64位加密，也就是loginUrl中formData的su参数"><a href="#用户名通过base64位加密，也就是loginUrl中formData的su参数" class="headerlink" title="用户名通过base64位加密，也就是loginUrl中formData的su参数"></a>用户名通过base64位加密，也就是loginUrl中formData的su参数</h3><pre><code># 得到su值base64加密的账号
def getSu(self):
    b64_username = su = base64.b64encode(self.userName.encode(encoding=&quot;utf-8&quot;))
    return su
</code></pre><h3 id="密码加密方式比较复杂，通过ssologin-js中查看，也就是loginUrl中formData的sp参数"><a href="#密码加密方式比较复杂，通过ssologin-js中查看，也就是loginUrl中formData的sp参数" class="headerlink" title="密码加密方式比较复杂，通过ssologin.js中查看，也就是loginUrl中formData的sp参数"></a>密码加密方式比较复杂，通过ssologin.js中查看，也就是loginUrl中formData的sp参数</h3><pre><code># 从加密文件中得到加密密码sp
def getSp(self,servertime,nonce,pubkey,rsakv):
    pubkey = int(pubkey, 16)
    # 65537是js加密文件文件中的固定值，原是十六进制数字10001
    key = rsa.PublicKey(pubkey, 65537)
    # 以下拼接明文从js加密文件中得到签名
    sign = str(servertime) + &apos;\t&apos; + str(nonce) + &apos;\n&apos; + str(self.password)
    sign = sign.encode(&apos;utf-8&apos;)
    //rsa加密
    sp = rsa.encrypt(sign, key)
    # 把二进制数据的每个字节转换成相应的2位十六进制表示形式。
    sp = binascii.b2a_hex(sp)
    return sp
</code></pre><h3 id="获取登录信息"><a href="#获取登录信息" class="headerlink" title="获取登录信息"></a>获取登录信息</h3><p>当然也可以用urllib3</p>
<pre><code>        import requests # pip install requests

        # 得到登录信息
requests.packages.urllib3.disable_warnings() 
def getInfo(self,su):
    print(u&apos;正在校验用户信息，请稍后...&apos;)
    while True:
         try:
             # 新浪微博做了登录加密处理
             preLoginUrl = &apos;https://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=%s&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)&amp;_=%s&apos; % (su,int(round(time.time() * 1000)))                                     
             r = requests.get(preLoginUrl, verify=False);
             if(r.status_code == 200):
                # 通过正则表达式取出sinaSSOController.preloginCallBack({jsonBody})内容部分与密码加密有关
                jsonBody = re.findall(r&apos;\((\{.*?\})\)&apos;, r.text)[0]
                data = json.loads(jsonBody)
                servertime = data[&apos;servertime&apos;]
                nonce = data[&apos;nonce&apos;]
                pubkey = data[&apos;pubkey&apos;]
                rsakv = data[&apos;rsakv&apos;]
             else:
                print(u&apos;preLoginUrl调用出错，错误响应码：%s&apos; % r.status_code)
                break
         except requests.exceptions.ConnectionError:
             print(&quot;校验失败，1s后重试...&quot;)
             time.sleep(1)
             continue
         return servertime,nonce,pubkey,rsakv 
</code></pre><h2 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h2><pre><code>       requests.packages.urllib3.disable_warnings() 
def getCookies(self,su, sp, servertime, nonce, rsakv):     
     print(u&apos;用户正在登录，请稍后...&apos;)
     while True:
         try:
             #实际登录地址
             loginUrl = &apos;https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19)&apos;
             #表单数据
             formData = {
               &apos;entry&apos;:&apos;weibo&apos;,
               &apos;gateway&apos;:&apos;1&apos;,
               &apos;from&apos;:&apos;&apos;,
               &apos;qrcode_flag&apos;:&apos;false&apos;,
               &apos;useticket&apos;:&apos;1&apos;,
               &apos;pagerefer&apos;:&apos;https://login.sina.com.cn/crossdomain2.php?action=logout&amp;r=https%3A%2F%2Fweibo.com%2Flogout.php%3Fbackurl%3D%252F&apos;,
               &apos;vsnf&apos;:&apos;1&apos;,
               &apos;su&apos;:su,
               &apos;service&apos;:&apos;miniblog&apos;,
               &apos;servertime&apos;:servertime,
               &apos;nonce&apos;:nonce,
               &apos;pwencode&apos;:&apos;rsa2&apos;,
               &apos;rsakv&apos;:rsakv,
               &apos;sp&apos;:sp,
               &apos;sr&apos;:&apos;1366*768&apos;,
               &apos;encoding&apos;:&apos;UTF-8&apos;,
               &apos;prelt&apos;:&apos;4959&apos;,
               &apos;url&apos;:&apos;https://weibo.com/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack&apos;,
               &apos;returntype&apos;:&apos;META&apos;
             }
             #请求头
             headers = {
               &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,
               &apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,
               &apos;Accept-Encoding&apos;:&apos;gzip, deflate, br&apos;,
               &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&apos;,
               &apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,
               &apos;Host&apos;:&apos;login.sina.com.cn&apos;,
               &apos;Referer&apos;:&apos;https://weibo.com/&apos;,
               &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;
             }
             #会话对象requests.Session能够跨请求地保持某些参数
             session = requests.Session()
             session.headers = headers
             response = session.post(loginUrl, data=formData, verify=False)
             result = response.content.decode(&apos;gbk&apos;)
             #正则表达式找到location.replace中的网页location.replace(&quot;https://login.sina.com.cn/crossdomain2.php?action=login&amp;entry=weibo&amp;r=https%3A%2F%2Fpassport.weibo.com%2Fwbsso%2Flogin%3Fssosavestate%3D1548839580%26url%3Dhttps%253A%252F%252Fweibo.com%252Fajaxlogin.php%253Fframelogin%253D1%2526callback%253Dparent.sinaSSOController.feedBackUrlCallBack%2526sudaref%253Dweibo.com%26display%3D0%26ticket%3DST-NTk3Njc3MDY4NQ%3D%3D-1517303580-gz-D57C7A6D615CC630C5CB53402C39C42C-1%26retcode%3D0&amp;sr=1366%2A768&quot;);
             # 并且得到location.replace中响应消息&lt;html&gt;&lt;head&gt;&lt;script language=&apos;javascript&apos;&gt;parent.sinaSSOController.feedBackUrlCallBack({&quot;result&quot;:true,&quot;userinfo&quot;:{&quot;uniqueid&quot;:&quot;5976770685&quot;,&quot;userid&quot;:null,&quot;displayname&quot;:null,&quot;userdomain&quot;:&quot;?wvr=5&amp;lf=reg&quot;},&quot;redirect&quot;:&quot;https:\/\/weibo.com\/nguide\/interest&quot;});&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
             info = re.findall(r&quot;location\.replace\(\&quot;(.*?)\&quot;&quot;, result)
             # 响应内容
             # {&quot;retcode&quot;:0,&quot;arrURL&quot;:[&quot;https:\/\/passport.weibo.com\/wbsso\/crossdomain?action=login&quot;,&quot;https:\/\/passport.97973.com\/sso\/crossdomain?action=login&quot;,&quot;https:\/\/passport.krcom.cn\/sso\/crossdomain?service=krvideo&amp;savestate=1&amp;action=login&quot;,&quot;https:\/\/passport.weibo.cn\/sso\/crossdomain?action=login&quot;]}
             res = requests.get(info[0], verify=False);
             jsonBody = re.findall(r&apos;\((\{.*?\})\)&apos;, res.text)[0]
             # 获取cookie cookies.get_dict()得到cookie字典
             cookies = response.cookies.get_dict()
             data = json.loads(jsonBody)
             if(data[&apos;retcode&apos;] == 0):  
                 print(u&apos;用户%s登录成功&apos; % self.userName)
                 return cookies
             elif(data[&apos;retcode&apos;] == 101):
                 print(data[&apos;reason&apos;])
                 return None
             else:
                print(u&apos;登录失败,原因：%s&apos; % data[&apos;reason&apos;])
                return None
         except requests.exceptions.ConnectionError:
             print(u&quot;登录尝试失败，1s后重试连接...&quot;)
             time.sleep(1)
             continue
</code></pre><h1 id="登录成功后，保存cookie，进行转发"><a href="#登录成功后，保存cookie，进行转发" class="headerlink" title="登录成功后，保存cookie，进行转发"></a>登录成功后，保存cookie，进行转发</h1><pre><code> # content 发送内容 mid 微博ID pdetail location 博主定位
requests.packages.urllib3.disable_warnings() 
def forward(self,contents,mid,domain,location,is_comment_base):
    requestCount = 0; #总请求次数
    successCount = 0; #成功次数
    # 通过登录接口获取用户cookie
    su = weibo.getSu()
    servertime,nonce,pubkey,rsakv=self.getInfo(su)
    sp = weibo.getSp(servertime,nonce,pubkey,rsakv)
    cookies = self.getCookies(su, sp,servertime,nonce,rsakv)
    print(u&apos;正在请求转发，请稍后...&apos;)
    while True:      
        try:
            content = CommonUtil.randomContent(contents)
            forwardUrl = &apos;https://weibo.com/aj/v6/mblog/forward?ajwvr=6&amp;domain=%s&amp;__rnd=%s&apos; % (domain,int(round(time.time() * 1000))) 

            formData = {
                &apos;pic_src&apos;:&apos;&apos;,
                &apos;pic_id&apos;:&apos;&apos;,
                &apos;appkey&apos;:&apos;&apos;,
                &apos;mid&apos;:mid,
                &apos;styletype&apos;:&apos;1&apos;,
                &apos;mark&apos;:&apos;&apos;,
                &apos;reason&apos;:content,
                &apos;location&apos;:&apos;page_%s_home&apos; % domain,
                &apos;pdetail&apos;:pdetail,
                &apos;module&apos;:&apos;&apos;,
                &apos;page_module_id&apos;:&apos;&apos;,
                &apos;refer_sort&apos;:&apos;&apos;,
                &apos;rank&apos;:&apos;0&apos;,
                # 给原博主评论
                #&apos;is_comment_base&apos;:&apos;1&apos;,
                &apos;rankid&apos;:&apos;&apos;,
                &apos;isReEdit&apos;:&apos;false&apos;,
                &apos;_t&apos;:&apos;0&apos;,
            }   
            if(is_comment_base == &apos;y&apos;):
                formData[&apos;is_comment_base&apos;] = &apos;1&apos;

            session = requests.Session()
            #请求头
            headers = {
               &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,
               &apos;Accept&apos;:&apos;*/*&apos;,
               &apos;Accept-Encoding&apos;:&apos;gzip, deflate, br&apos;,
               &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.9&apos;,
               &apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;,
               &apos;Origin&apos;:&apos;https://weibo.com&apos;,
               &apos;Host&apos;:&apos;weibo.com&apos;,
               &apos;Referer&apos;:&apos;https://weibo.com/u/5783494388?is_all=1&apos;,
               &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;,
               &apos;X-Requested-With&apos;:&apos;XMLHttpRequest&apos;,
            }
            session.headers = headers  
            time.sleep(2)#2s发送一次请求
            response = session.post(forwardUrl, data=formData,cookies=cookies, verify=False)
            result = response.content.decode(&apos;gbk&apos;)
            data = json.loads(result)
            requestCount = requestCount + 1 #记录请求数
            if(data[&apos;code&apos;] == &apos;100000&apos;):
                successCount = successCount + 1 #记录成功数
                print(u&apos;转发内容：%s 成功次数：%s&apos; % (content,successCount))
            elif(data[&apos;code&apos;] == &apos;100027&apos;):
                print(u&apos;转发失败，进入小黑屋，停止转发,请更换账号，失败原因：%s  %s&apos; % (data[&apos;code&apos;],data[&apos;msg&apos;]))
                print(u&apos;%s目前转发成功次数：%s&apos; %(self.userName,successCount))  
                break
            elif(data[&apos;code&apos;] == &apos;100001&apos; and &apos;微博发的太多啦，休息一会再发啦&apos; in data[&apos;msg&apos;]):
                print(u&apos;微博发送太频繁，休息1分钟重试，失败原因%s(%s)&apos; %(data[&apos;code&apos;],data[&apos;msg&apos;]))
                time.sleep(60)
                continue
            else:
                print(u&apos;转发失败，失败原因:%s  %s&apos; %(data[&apos;code&apos;],data[&apos;msg&apos;]))
                print(u&apos;%s目前转发成功次数：%s&apos; %(self.userName,successCount)) 
            #if(requestCount &gt;= setCount):
                #print(u&apos;用户%s转发成功次数：%s&apos; %(self.userName,successCount))
                #break
        except requests.exceptions.ConnectionError:
             print(&quot;转发尝试失败，1s后重试连接...&quot;)
             time.sleep(1)
             continue 
    print(u&apos;总共转发%s次&apos; %successCount) 
</code></pre><h1 id="基础工具类"><a href="#基础工具类" class="headerlink" title="基础工具类"></a>基础工具类</h1><pre><code>class CommonUtil:
         @staticmethod
         def randomContent(contents):
              return str(random.sample(contents, 1)[0])
         @staticmethod
         def decodeUTF8(str):
             return str.decode(&quot;UTF-8&quot;)
         @staticmethod
         def decodeGBK(str):
             return str.decode(&quot;GBK&quot;) 
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/JDK8新增的StampedLock锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/JDK8新增的StampedLock锁/" itemprop="url">JDK8新增的StampedLock锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T16:52:01+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="StampedLock锁模式"><a href="#StampedLock锁模式" class="headerlink" title="StampedLock锁模式"></a>StampedLock锁模式</h2><ol>
<li>writeLock 写锁，独占锁或者排他锁、是阻塞的。</li>
</ol>
<blockquote>
<p>同时只有一个线程可以获取该锁，当一个线程获取该锁后，其它请求的线程必须等待，当目前没有线程持有读锁或者写锁的时候才可以获取到该锁，请求该锁成功后会返回一个stamp变量用来表示该锁的版本，当释放该锁时候需要unlockWrite并传递参数stamp</p>
</blockquote>
<pre><code>//返回一个可用于解锁或转换模式的标志
public long writeLock() {
            long s, next;  // 当完全解锁时才能获得下一个锁
            return ((((s = state) &amp; ABITS) == 0L &amp;&amp;
                     U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ?
                                        next : acquireWrite(false, 0L));
}
</code></pre><p>  <strong>使用情形：读少写多</strong></p>
<ol>
<li>readLock 悲观读锁，共享锁，是非阻塞的。</li>
</ol>
<blockquote>
<p>没有线程获取独占写锁的情况下，同时多个线程可以获取该锁，如果已经有线程持有写锁，其他线程请求获取该读锁会被阻塞</p>
</blockquote>
<pre><code>//返回一个可用于解锁或转换模式的标志
public long readLock() {
    long s = state, next;  // 常见的非竞争情况上获取锁
    return ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;
             U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ?
            next : acquireRead(false, 0L));
}
</code></pre><p> <strong>使用情形：读少写多</strong></p>
<ol>
<li>tryOptimisticRead 乐观锁</li>
</ol>
<blockquote>
<p>是相对于悲观锁来说的，在操作数据前并没有通过CAS设置锁的状态，如果当前没有线程持有写锁，则简单的返回一个非0的stamp版本信息，获取该stamp后在具体操作数据前还需要调用validate验证下该stamp是否已经不可用，也就是看当调用tryOptimisticRead返回stamp后到到当前时间间是否有其他线程持有了写锁，如果是那么validate会返回0，否者就可以使用该stamp版本的锁对数据进行操作。由于tryOptimisticRead并没有使用CAS设置锁状态所以不需要显示的释放该锁</p>
</blockquote>
<pre><code>//Returns a stamp that can later be validated, or zero if exclusively locked.
public long tryOptimisticRead() {
    long s;
    return (((s = state) &amp; WBIT) == 0L) ? (s &amp; SBITS) : 0L;
}
</code></pre><p> <strong>使用情形：读多写少</strong></p>
<blockquote>
<p><strong>TIPS：获取读锁只是使用与或操作进行检验，不涉及CAS操作，所以效率会高很多，但是同时由于没有使用真正的锁，在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的</strong></p>
</blockquote>
<p> JDK注释使用方式</p>
<pre><code>class Point {
    private double x, y;
    private final StampedLock sl = new StampedLock();
    //独占锁
    void move(double deltaX, double deltaY) { // an exclusively locked method
     long stamp = sl.writeLock();
      try {
        x += deltaX;
        y += deltaY;
      } finally {
        sl.unlockWrite(stamp);
     }
   }
    //乐观锁
    double distanceFromOrigin() { // A read-only method
      //1. 获取乐观锁
      long stamp = sl.tryOptimisticRead();
      //2. 将全部变量拷贝到方法体栈内
      double currentX = x, currentY = y;
      //3. 校验锁是否被抢占
      if (!sl.validate(stamp)) {
         //4. 如果被抢占则获取一个共享读锁
         stamp = sl.readLock();
         try {
           // 将全部变量拷贝到方法体栈内
           currentX = x;
           currentY = y;
         } finally {
            // 释放共享锁
            sl.unlockRead(stamp);
         }
      }
      return Math.sqrt(currentX * currentX + currentY * currentY);
    }
   //共享锁
    void moveIfAtOrigin(double newX, double newY) { // upgrade
      // Could instead start with optimistic, not read mode
      long stamp = sl.readLock();
      try {
        // 如果当前点在原点则移动
        while (x == 0.0 &amp;&amp; y == 0.0) {
          // 尝试将获取的读锁升级为写锁
          long ws = sl.tryConvertToWriteLock(stamp);
          // 升级成功，则更新stamp，并设置坐标值，然后退出循环
          if (ws != 0L) {
            stamp = ws;
            x = newX;
            y = newY;
            break;
          }
          else {
            // 读锁升级写锁失败则释放度锁，显示获取独占锁，然后循环重试
            sl.unlockRead(stamp);
            stamp = sl.writeLock();
          }
        }
      } finally {
        sl.unlock(stamp);
      }
    }
  }}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/logback异步日志/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/logback异步日志/" itemprop="url">logback异步日志</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T17:10:39+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/异步日志/" itemprop="url" rel="index">
                    <span itemprop="name">异步日志</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="异步日志类"><a href="#异步日志类" class="headerlink" title="异步日志类"></a>异步日志类</h2><pre><code>ch.qos.logback.classic.AsyncAppender
</code></pre><h2 id="异步日志配置"><a href="#异步日志配置" class="headerlink" title="异步日志配置"></a>异步日志配置</h2><pre><code>&lt;appender name=&quot;asyncAppender&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&gt;    
                   &lt;!-- config options --&gt;
                 &lt;!-- 设置非阻塞模式 --&gt;
       &lt;neverBlock&gt;true&lt;/neverBlock&gt;
       &lt;!-- 设置队列大小，默认256 --&gt;
       &lt;queueSize&gt;1024&lt;/queueSize&gt;
       &lt;!-- 当队列的剩余容量小于这个discardingThreshold并且当前日志level TRACE, DEBUG or INFO ，则丢弃这些日志 --&gt;
       &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;
       &lt;!-- 引用普通同步日志 --&gt;
       &lt;appender-ref ref=&quot;taskLogAppender&quot;/&gt;
&lt;/appender&gt;
</code></pre><h3 id="discardingThreshold"><a href="#discardingThreshold" class="headerlink" title="discardingThreshold"></a>discardingThreshold</h3><pre><code> @Override
 protected void append(E eventObject) {
     //当队列的剩余容量小于这个discardingThreshold,且当前日志level TRACE, DEBUG or INFO ，则丢弃这些日志
     if (isQueueBelowDiscardingThreshold() &amp;&amp; isDiscardable(eventObject)) {
         return;
     }
     preprocess(eventObject);
     put(eventObject);
 }

 private boolean isQueueBelowDiscardingThreshold() {
     return (blockingQueue.remainingCapacity() &lt; discardingThreshold);
 }

 protected boolean isDiscardable(ILoggingEvent event) {
   Level level = event.getLevel();
   return level.toInt() &lt;= Level.INFO_INT;
}
</code></pre><p>logback本质是一个<code>BlockingQueue&lt;E&gt; blockingQueue</code></p>
<p>当调用put方法添加元素时候<strong>neverBlock=true</strong>时，调用的是offer方法；否则，调用的是put方法。</p>
<pre><code> private void put(E eventObject) {
    if (neverBlock) {
        blockingQueue.offer(eventObject);
    } else {
        try {
            blockingQueue.put(eventObject);
        } catch (InterruptedException e) {
            // Interruption of current thread when in doAppend method should not be consumed
            // by AsyncAppender
            Thread.currentThread().interrupt();
        }
    }
}       
</code></pre><p>ArrayBlockingQueue#offer方法是非阻塞的。</p>
<pre><code>public boolean offer(E e) {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        if (count == items.length)
            return false;
        else {
            enqueue(e);
            return true;
        }
    } finally {
        lock.unlock();
    }
}
</code></pre><p>ArrayBlockingQueue#put</p>
<pre><code>public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await();
        enqueue(e);
    } finally {
        lock.unlock();
    }
}
</code></pre><p> 如果调用的是put方法，当队列满时，会挂起当前线程。所以设置异步日志方法需要将neverBlock设置为true</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/JDK8新增ThreadLocalRandom类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/JDK8新增ThreadLocalRandom类/" itemprop="url">JDK8新增ThreadLocalRandom类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T15:39:07+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Random使用"><a href="#Random使用" class="headerlink" title="Random使用"></a>Random使用</h2><pre><code>  //使用默认随机数生成器（会生成一个默认的值seedUniquifier() ^ System.nanoTime()）
Random rand = new Random();
for(int i = 0; i &lt; 10; i ++){
    System.out.println(rand.nextInt(5) );
}
</code></pre><h2 id="和Random类的区别"><a href="#和Random类的区别" class="headerlink" title="和Random类的区别"></a>和Random类的区别</h2><p>为了解决多线程高并发下Random的缺陷，JUC包下新增了ThreadLocalRandom类。ThreadLocalRandom继承Random类。</p>
<h4 id="如何生成随机数？"><a href="#如何生成随机数？" class="headerlink" title="如何生成随机数？"></a>如何生成随机数？</h4><pre><code>public int nextInt(int bound) {
    //参数检查
    if (bound &lt;= 0)
        throw new IllegalArgumentException(BadBound);
    //*根据老种子生成新种子
    int r = next(31);
    //*根据新种子计算新随机数
    int m = bound - 1;
    if ((bound &amp; m) == 0)  // i.e., bound is a power of 2
        r = (int)((bound * (long)r) &gt;&gt; 31);
    else {
        for (int u = r;
             u - (r = u % bound) + m &lt; 0;
             u = next(31))
            ;
    }
    return r;
}
</code></pre><p>在单线程情况下每次调用nextInt都是根据老的种子计算出来新的种子，这是可以保证随机数产生的随机性的。在多线程下多个线程可能都拿同一个老的种子去计算新的种子，这会导致多个线程产生的新种子是一样的，会导致多个线程产生相同的随机值。为了保证多线程下产生的随机数是随机的，在创建Random对象时候初始化的种子就保存到了种子原子变量里面</p>
<pre><code>  protected int next(int bits) {
    long oldseed, nextseed;
    AtomicLong seed = this.seed;
    do {
        //获取当前原子变量种子的值
        oldseed = seed.get();
        //根据当前种子值计算新的种子
        nextseed = (oldseed * multiplier + addend) &amp; mask;
        //CAS操作会保证只有一个线程可以更新老的种子为新的，失败的线程会通过循环从新获取更新后的种子作为当前种子去计算老的种子,保证了随机数的随机性
    } while (!seed.compareAndSet(oldseed, nextseed));
   //使用固定算法根据新的种子计算随机数
    return (int)(nextseed &gt;&gt;&gt; (48 - bits));
}
</code></pre><p> 多个线程同时计算随机数计算新的种子时候多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试，这是会降低并发性能。ThreadLocalRandom解决这个问题</p>
<h2 id="ThreadLocalRandom基本使用"><a href="#ThreadLocalRandom基本使用" class="headerlink" title="ThreadLocalRandom基本使用"></a>ThreadLocalRandom基本使用</h2><pre><code>//获取当前线程的随机数生成器
ThreadLocalRandom rand = ThreadLocalRandom.current();
for(int i = 0; i &lt; 10; i ++){
    System.out.println(rand.nextInt(5) );
}
</code></pre><p>  ThreadLocal的出现就是为了解决多线程访问一个变量时候需要进行同步的问题，让每一个线程拷贝一份变量，每个线程对变量进行操作时候实际是操作自己本地内存里面的拷贝，从而避免了对共享变量进行同步。Random的缺点是多个线程会使用原子性种子变量，会导致对原子变量更新的竞争。ThreadLocalRandom 让每个线程维护自己的一个种子变量，每个线程生成随机数时候根据自己老的种子计算新的种子，并使用新种子更新老的种子，然后根据新种子计算随机数，就不会存在竞争问题，这会大大提高并发性能</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/JDK8原子操作类——LongAdder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/JDK8原子操作类——LongAdder/" itemprop="url">JDK8原子操作类——LongAdder</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T13:51:46+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="与AtomicLong有什么区别？"><a href="#与AtomicLong有什么区别？" class="headerlink" title="与AtomicLong有什么区别？"></a>与AtomicLong有什么区别？</h2><p>AtomicLong通过CAS操作提供非阻塞的原子操作，但是CAS失败是通过无限循环的自旋锁不断尝试的。</p>
<pre><code>int prev, next;
do {
    ...
} while (!compareAndSet(prev, next));
</code></pre><p>  在高并发条件下，同时去操作一个变量会造成大量线程CAS失败然后处于自旋状态，这大大浪费了cpu资源，降低了并发性。<strong>LongAdder根据把一个变量分解为多个变量，让同样多的线程去竞争多个资源</strong>，可以解决Atomic带来的资源浪费问题。LongAdder解决失败的问题不是CAS循环重试，而是<strong>尝试获取其他原子变量的锁，最后获取当前值时候是把所有变量的值累加后返回。</strong></p>
<p>  一个延迟初始化的原子性更新数组<code>transient volatile Cell[] cells</code>和一个基值变量<code>transient volatile long base</code>数组的大小保持是2的N次方大小，数组表的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型<strong>Cell类型是AtomicLong的一个改进，用来减少缓存的争用</strong>。由于Cell占用内存空间比较大，所以是惰性加载。当一开始没有空间时候，所有的更新都是操作base变量。</p>
<p>  <code>transient volatile int cellsBusy</code> 初始化和扩容数组表使用。当一次线程发现当前下标的元素获取锁失败后，会尝试获取其他下表的元素的锁，最后获取当前值时候是把所有变量的值累加后返回。<strong>累加过程中并没有使用锁，所以在计算返回值时候可能某些元素的值已经被修改了，但是返回值是一个快照值，保证了弱一致性</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/05/ThreadLocal源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/05/ThreadLocal源码解析/" itemprop="url">ThreadLocal源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-05T14:07:07+08:00">
                2018-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ThreadLocal的成员变量</p>
<pre><code>    //ThreadLocal通过threadLocalHashCode来标识每一个ThreadLocal的唯一性
private final int threadLocalHashCode = nextHashCode();

/**
 * The next hash code to be given out. Updated atomically. Starts at
 * zero.
 */
private static AtomicInteger nextHashCode = new AtomicInteger();

/**
 * threadLocalHashCode通过CAS操作进行更新，每次hash操作的增量为0x61c88647
 */
private static final int HASH_INCREMENT = 0x61c88647;

/**
 * Returns the next hash code.
 */
private static int nextHashCode() {
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}
</code></pre><h2 id="SET方法"><a href="#SET方法" class="headerlink" title="SET方法"></a>SET方法</h2><pre><code>public void set(T value) {
    Thread t = Thread.currentThread();
    //将当前线程引用传给ThreadLocalMap对象
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre><h2 id="getMap"><a href="#getMap" class="headerlink" title="getMap"></a>getMap</h2><pre><code>  //每个线程通过ThreadLocal.ThreadLocalMap与ThreadLocal相绑定。确保每个线程访问到的thread-local variable都是本线程的
 ThreadLocalMap getMap(Thread t) {
   return t.threadLocals;
 }

 /* ThreadLocal values pertaining to this thread. This map is maintained
* by the ThreadLocal class. */
 ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre><h2 id="createMap"><a href="#createMap" class="headerlink" title="createMap"></a>createMap</h2><p>如果ThreadLocalMap不为空则调用ThreadLocalMap.ThreadLocalMap#set方法设值；</p>
<p>若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给Thread.threadLocals</p>
<pre><code>    /**
 * Create the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param t the current thread
 * @param firstValue value for the initial entry of the map
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
</code></pre><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap是ThreadLocal的静态内部类</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>/**
 * 代表Map的初始容量
 */
private static final int INITIAL_CAPACITY = 16;

/**
 * 是一个Entry类型的数组，用于存储数据
 */
private Entry[] table;

/**
 * size代表表中的存储数目
 */
private int size = 0;

/**
 * threshold代表需要扩容时对应size的阈值
 */
private int threshold; // Default to 0

private void setThreshold(int len) {
    threshold = len * 2 / 3;
}
</code></pre><h2 id="Entry是ThreadLocalMap的静态内部类。存储数据"><a href="#Entry是ThreadLocalMap的静态内部类。存储数据" class="headerlink" title="Entry是ThreadLocalMap的静态内部类。存储数据"></a>Entry是ThreadLocalMap的静态内部类。存储数据</h2><pre><code>/**
 * 每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了
 */
static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
     Entry(ThreadLocal&lt;?&gt; k, Object v) {
         super(k);
         value = v;
     }
 }
</code></pre><h2 id="ThreadLocalMap构造函数"><a href="#ThreadLocalMap构造函数" class="headerlink" title="ThreadLocalMap构造函数"></a>ThreadLocalMap构造函数</h2><pre><code>//构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量
ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {
     //构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold
     table = new Entry[INITIAL_CAPACITY];
     int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);
     table[i] = new Entry(firstKey, firstValue);
     size = 1;
     setThreshold(INITIAL_CAPACITY);
 }
</code></pre><p> <strong>计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是2的指数，因为这可以使得hash发生冲突的次数减小</strong></p>
<h2 id="ThreadLocalMap-set"><a href="#ThreadLocalMap-set" class="headerlink" title="ThreadLocalMap#set"></a>ThreadLocalMap#set</h2><pre><code>private void set(ThreadLocal&lt;?&gt; key, Object value) {

     // We don&apos;t use a fast path as with get() because it is at
     // least as common to use set() to create new entries as
     // it is to replace existing ones, in which case, a fast
     // path would fail more often than not.

     Entry[] tab = table;
     int len = tab.length;
     int i = key.threadLocalHashCode &amp; (len-1);

     for (Entry e = tab[i];
          e != null;
          e = tab[i = nextIndex(i, len)]) {
         ThreadLocal&lt;?&gt; k = e.get();

         if (k == key) {
             e.value = value;
             return;
         }

         if (k == null) {
             replaceStaleEntry(key, value, i);
             return;
         }
     }

     tab[i] = new Entry(key, value);
     int sz = ++size;
     if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
         rehash();
 }
</code></pre><p>  如果hash碰撞 nextIndex重新计算hash值。ThreadLocalMap解决冲突的方法是线性探测法（不断加1），而不是HashMap的链地址法，这一点也能从Entry的结构上推断出来</p>
<pre><code>private static int nextIndex(int i, int len) {
     return ((i + 1 &lt; len) ? i + 1 : 0);
 }
</code></pre><hr>
<pre><code>private void set(ThreadLocal&lt;?&gt; key, Object value) {

     // We don&apos;t use a fast path as with get() because it is at
     // least as common to use set() to create new entries as
     // it is to replace existing ones, in which case, a fast
     // path would fail more often than not.

     Entry[] tab = table;
     int len = tab.length;
     int i = key.threadLocalHashCode &amp; (len-1);

     for (Entry e = tab[i];
          e != null;
          e = tab[i = nextIndex(i, len)]) {
         ThreadLocal&lt;?&gt; k = e.get();

         if (k == key) {
             e.value = value;
             return;
         }

         if (k == null) {
             replaceStaleEntry(key, value, i);
             return;
         }
     }

     tab[i] = new Entry(key, value);
     int sz = ++size;
     if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
         rehash();
 }
</code></pre><p>若是经历了上面步骤没有命中hash，也没有发现无用的Entry，set方法就会创建一个新的Entry，并会进行启发式的垃圾清理，用于清理无用的Entry。主要通过cleanSomeSlots方法进行清理</p>
<pre><code>private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;&amp; e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}

/**
 * Version of getEntry method for use when key is not found in
 * its direct hash slot.
 *
 * @param  key the thread local object
 * @param  i the table index for key&apos;s hash code
 * @param  e the entry at table[i]
 * @return the entry associated with key, or null if no such
 */
private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key)
            return e;
        if (k == null)
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}
</code></pre><p><strong>rehash操作会执行一次全表的扫描清理工作，并在size大于等于threshold的四分之三时进行resize，即扩容一倍。因此ThreadLocalMap的加载因子一样为0.75。</strong></p>
<pre><code>private void resize() {
     Entry[] oldTab = table;
     int oldLen = oldTab.length;
     int newLen = oldLen * 2;
     Entry[] newTab = new Entry[newLen];
     int count = 0;

     for (int j = 0; j &lt; oldLen; ++j) {
         Entry e = oldTab[j];
         if (e != null) {
             ThreadLocal&lt;?&gt; k = e.get();
             if (k == null) {
                 e.value = null; // Help the GC
             } else {
                 int h = k.threadLocalHashCode &amp; (newLen - 1);
                 while (newTab[h] != null)
                     h = nextIndex(h, newLen);
                 newTab[h] = e;
                 count++;
             }
         }
     }

     setThreshold(newLen);
     size = count;
     table = newTab;
 }
</code></pre><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>ThreadLocal的get方法就是调用了ThreadLocalMap的getEntry方法</p>
<pre><code>   public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
</code></pre><h2 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h2><pre><code>private void remove(ThreadLocal&lt;?&gt; key) {
         Entry[] tab = table;
         int len = tab.length;
         int i = key.threadLocalHashCode &amp; (len-1);
         for (Entry e = tab[i];
              e != null;
              e = tab[i = nextIndex(i, len)]) {
             if (e.get() == key) {
                 e.clear();
                 expungeStaleEntry(i);
                 return;
             }
         }
     }
</code></pre><p> <a href="http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/" target="_blank" rel="external">参考</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/29/Java红包算法简单实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/29/Java红包算法简单实现/" itemprop="url">Java红包算法简单实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T15:36:06+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="判断红包是否领完"><a href="#判断红包是否领完" class="headerlink" title="判断红包是否领完"></a>判断红包是否领完</h1><pre><code>   //假设每人领取最大200元/最小0.01元 
 private static final double MIN_MONEY = 0.01;
 private static final double MAX_MONEY = 200;

   /**
 * 
 * isFinished 判断红包是否领取完  根据平均金额判断红包内的金钱是否发放完
 * @param currentMoney 当前金额
 * @param currentCount 当前领取红包数
 * @return
 */
public static boolean isFinished(double currentMoney,int currentCount){
    double avg = currentMoney / currentCount;
    if(avg &lt; MIN_MONEY){
        return false;
    }else if(avg &gt; MAX_MONEY){
        return false;
    }
    return true;
}
</code></pre><h1 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h1><pre><code>  /**
 * 
 * randomRedPacket 核心随机生成红包算法
 * @param totalMoney 红包金额
 * @param totalCount 红包数量
 * @param minMoney 最小红包
 * @param maxMoney 最大红包
 * @return
 */
public static double randomRedPacket(double totalMoney,int totalCount,double minMoney,double maxMoney){
    //如果是单发红包，则对方全领
    if(totalCount == 1){
        return (double)Math.round(totalMoney*100) / 100;
    }
    //如果最小红包和最大红包相等，默认最小红包
    if(minMoney == maxMoney){
        return minMoney;
    }
    //设置最大值，防止红包溢出
    double maxMoney_ = maxMoney &gt; totalMoney ? totalMoney :maxMoney;
    //随机分配红包(生成随机红包范围：minMoney &lt; distributionMoney &lt; maxMoney_)
    double distributionMoney = (double)Math.round(((double)Math.random() * (maxMoney_ - minMoney) + minMoney )*100) / 100;
    //得到剩余红包
    double remainMoney = totalMoney - distributionMoney;
    //红包是否领完 
    if(isFinished(remainMoney, totalCount-1)){
        return distributionMoney;
    }else{ //剩余红包随机分配
        double avg = remainMoney / (totalCount -1);
        if(avg &lt; MIN_MONEY){
            return randomRedPacket(totalMoney, totalCount, minMoney, distributionMoney);
        }else if(avg &gt; MAX_MONEY){
            return randomRedPacket(totalMoney, totalCount, distributionMoney, maxMoney);
        }
    }
    return distributionMoney;
}
</code></pre><h1 id="得到用户红包"><a href="#得到用户红包" class="headerlink" title="得到用户红包"></a>得到用户红包</h1><pre><code>private static final float TIMES = 2.1f;

/**
 * 
 * openRedPacket 用户红包分配详情
 * @param totalMoney
 * @param totalCount
 * @return
 */
public static List&lt;Double&gt; openRedPacket(double totalMoney,int totalCount){
    if(!isFinished(totalMoney, totalCount)){
        return null;
    }
    List&lt;Double&gt; distributionMoneyList = new ArrayList&lt;Double&gt;();
    //如果随机生成的红包大于指定最大值，则默认
    double max = (double) totalMoney * TIMES / totalCount &gt; MAX_MONEY ? MAX_MONEY : (double) totalMoney * TIMES / totalCount;
    //将获得的红包放入集合
    for(int i = 0; i  &lt; totalCount ; i ++){
        double distributionMoney = randomRedPacket(totalMoney, totalCount - i, MIN_MONEY, max);
        distributionMoneyList.add(distributionMoney);
        totalMoney -= distributionMoney;
    }
    return distributionMoneyList;
}
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code>   public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    System.out.println(&quot;请输入红包金额：&quot;);
    double money = scan.nextDouble();
    System.out.println(&quot;请输入红包数量：&quot;);
    int count = scan.nextInt();

    List&lt;Double&gt; list = openRedPacket(money, count);
    Double [] redMoney = new Double[count];
    for(int i = 0; i &lt; list.size(); i ++){
        redMoney[i] = list.get(i);
    }
    for(int i = 0; i &lt; count; i ++){
        System.out.println(&quot;用户&quot;+i+&quot;得到红包&quot;+redMoney[i]+&quot;元&quot;);
    }

}
</code></pre><h1 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h1><pre><code>        请输入红包金额：
11
请输入红包数量：
11

用户0得到红包0.16元
用户1得到红包1.06元
用户2得到红包1.57元
用户3得到红包1.28元
用户4得到红包1.6元
用户5得到红包0.87元
用户6得到红包0.19元
用户7得到红包1.24元
用户8得到红包1.61元
用户9得到红包0.77元
用户10得到红包0.65元
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/30/RxJava介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/RxJava介绍/" itemprop="url">RxJava介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T13:47:00+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Rx模式"><a href="#Rx模式" class="headerlink" title="Rx模式"></a>Rx模式</h1><h2 id="使用观察者模式"><a href="#使用观察者模式" class="headerlink" title="使用观察者模式"></a>使用观察者模式</h2><ul>
<li>创建：Rx可以方便的创建事件流和数据流</li>
<li>组合：Rx使用查询式的操作符组合和变换数据流</li>
<li>监听：Rx可以订阅任何可观察的数据流并执行操作</li>
</ul>
<h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><ul>
<li>函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态</li>
<li>简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码</li>
<li>异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制</li>
<li>轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题</li>
</ul>
<h2 id="Observable的优势"><a href="#Observable的优势" class="headerlink" title="Observable的优势"></a>Observable的优势</h2><blockquote>
<p>Rx扩展了观察者模式用于支持数据和事件序列，添加了一些操作符，它让你可以声明式的组合这些序列，而无需关注底层的实现：如线程、同步、线程安全、并发数据结构和非阻塞IO</p>
</blockquote>
<h1 id="RxJava介绍"><a href="#RxJava介绍" class="headerlink" title="RxJava介绍"></a>RxJava介绍</h1><h2 id="为什么会有RxJava？"><a href="#为什么会有RxJava？" class="headerlink" title="为什么会有RxJava？"></a>为什么会有RxJava？</h2><blockquote>
<p>减少REST调用的次数。取代几十次的REST调用，而是让客户端自己处理需要的数据，他们决定基于客户端需求创建一个专门优化过的REST调用。</p>
</blockquote>
<h2 id="RxJava主要特性"><a href="#RxJava主要特性" class="headerlink" title="RxJava主要特性"></a>RxJava主要特性</h2><ul>
<li>易于并发从而更好的利用服务器的能力</li>
<li>易于有条件的异步执行</li>
<li>一种更好的方式来避免回调地狱</li>
<li>一种响应式方法</li>
</ul>
<h2 id="RxJava新特性"><a href="#RxJava新特性" class="headerlink" title="RxJava新特性"></a>RxJava新特性</h2><ul>
<li>生产者在没有更多数据可用时能够发出信号通知：<code>onCompleted()</code>事件</li>
<li>生产者在发生错误时能够发出信号通知：<code>onError()</code>事件</li>
<li>RxJava Observables 能够组合而不是嵌套，从而避免开发者陷入回调地狱</li>
</ul>
<p>Observables和Iterables共用一个相似的API,在Iterable可以执行的许多操作也都同样可以在Observables上执行，除了remove</p>
<h2 id="RxJava角色"><a href="#RxJava角色" class="headerlink" title="RxJava角色"></a>RxJava角色</h2><ul>
<li>Observable</li>
<li>Observer</li>
<li>Subscriber</li>
<li>Subjects</li>
</ul>
<p>Observables和Subjects是两个“生产”实体<br>Observers和Subscribers是两个“消费”实体</p>
<h2 id="热Observables和冷Observables"><a href="#热Observables和冷Observables" class="headerlink" title="热Observables和冷Observables"></a>热Observables和冷Observables</h2><blockquote>
<p>从发射物的角度来看，有两种不同的Observables:热的和冷的。<strong>一个”热”的Observable典型的只要一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。</strong></p>
</blockquote>
<ul>
<li>获取数据 <code>onNext()</code></li>
<li>异常处理 <code>onError(Exception)</code></li>
<li>任务完成 <code>onCompleted()</code></li>
</ul>
<p><a href="http://dzxlar.cn/2017/06/05/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer%EF%BC%89/" target="_blank" rel="external">观察者模式</a></p>
<p><a href="https://www.gitbook.com/book/yuxingxin/rxjava-essentials-cn/details" target="_blank" rel="external">RxJava中文文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/Eureka源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/Eureka源码解析/" itemprop="url">Eureka源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T16:53:44+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SpringBoot注册到EurekaServer服务器列表</p>
<ol>
<li><code>@EnableDiscoveryClient</code> 激活Eureka中的DiscoveryClient实现</li>
<li><code>eureka.client.serviceUrl.defaultZone=http://localhost:10010/eureka/</code> 指定服务器注册中心</li>
</ol>
<h3 id="EnableDiscoveryClient实现"><a href="#EnableDiscoveryClient实现" class="headerlink" title="@EnableDiscoveryClient实现"></a>@EnableDiscoveryClient实现</h3><p>开启DiscoveryClient</p>
<pre><code>/**
 * Annotation to enable a DiscoveryClient implementation.
 * @author Spencer Gibb
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(EnableDiscoveryClientImportSelector.class)
public @interface EnableDiscoveryClient {

}
</code></pre><h3 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h3><p>DiscoveryClient职责</p>
<ol>
<li>向EurekaServer注册服务</li>
<li>向EurekaServer租约续期</li>
<li>当服务器关闭时，取消租约</li>
<li>查询EureServer中的服务列表</li>
<li>EurekaClient需要配置一个EurekaServer URL列表</li>
</ol>
<p>根据配置属性<code>eureka.client.serviceUrl.defaultZone</code>从DiscoveryClient中找到serviceUrl</p>
<pre><code>private final EndpointUtils.ServiceUrlRandomizer urlRandomizer;
</code></pre><p>EndpointUtils中找到<code>getServiceUrlsFromConfig</code>方法</p>
<blockquote>
<p>Get the list of all eureka service urls from properties file for the eureka client to talk to.<br>从配置文件中得到所有eureka的serviceUrl与EurekaClient进行对话</p>
</blockquote>
<p>参数</p>
<ul>
<li>clientConfig clientConfig中使用</li>
<li>instanceZone 客户端所在的Zone</li>
<li>preferSameZone 必须选择与客户端相同的Zone</li>
</ul>
<pre><code>     public static List&lt;String&gt; getServiceUrlsFromConfig(EurekaClientConfig clientConfig, String instanceZone, boolean preferSameZone) {
    List&lt;String&gt; orderedUrls = new ArrayList&lt;String&gt;();
    String region = getRegion(clientConfig);
    String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
    if (availZones == null || availZones.length == 0) {
        availZones = new String[1];
        availZones[0] = DEFAULT_ZONE;
    }
    logger.debug(&quot;The availability zone for the given region {} are {}&quot;, region, availZones);
    int myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);

    List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);
    if (serviceUrls != null) {
        orderedUrls.addAll(serviceUrls);
    }
    int currentOffset = myZoneOffset == (availZones.length - 1) ? 0 : (myZoneOffset + 1);
    while (currentOffset != myZoneOffset) {
        serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[currentOffset]);
        if (serviceUrls != null) {
            orderedUrls.addAll(serviceUrls);
        }
        if (currentOffset == (availZones.length - 1)) {
            currentOffset = 0;
        } else {
            currentOffset++;
        }
    }

    if (orderedUrls.size() &lt; 1) {
        throw new IllegalArgumentException(&quot;DiscoveryClient: invalid serviceUrl specified!&quot;);
    }
    return orderedUrls;
}
</code></pre><p>方法中可以得到两个内容Region、Zone</p>
<pre><code>String region = getRegion(clientConfig);
String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
</code></pre><p>tip：<strong>一个微服务只可以属于一个region</strong>，不特别配置，region和zone值就为default，如果需要自定义可以通过<code>eureka.client.region</code>设置</p>
<pre><code>public static String getRegion(EurekaClientConfig clientConfig) {
    String region = clientConfig.getRegion();
    if (region == null) {
        region = DEFAULT_REGION;
    }
    region = region.trim().toLowerCase();
    return region;
}
</code></pre><p>EurekaClientConfigBean是EurekaClientConfig实现类</p>
<p><code>getAvailabilityZones</code>如果未配置region，会采用默认defaultZone，这就是<code>eureka.client.serviceUrl.defaultZone</code>配置参数的由来</p>
<p>   public String[] getAvailabilityZones(String region) {<br>        String value = this.availabilityZones.get(region);<br>        if (value == null) {<br>            value = DEFAULT_ZONE;<br>        }<br>        return value.split(“,”);<br>    }</p>
<p><strong>Region和Zone之间的关系是一对多关系</strong></p>
<h2 id="ServiceUrls"><a href="#ServiceUrls" class="headerlink" title="ServiceUrls"></a>ServiceUrls</h2><p>具体实现</p>
<pre><code>public List&lt;String&gt; getEurekaServerServiceUrls(String myZone) {
    String serviceUrls = this.serviceUrl.get(myZone);
    if (serviceUrls == null || serviceUrls.isEmpty()) {
        serviceUrls = this.serviceUrl.get(DEFAULT_ZONE);
    }
    if (!StringUtils.isEmpty(serviceUrls)) {
        final String[] serviceUrlsSplit = StringUtils.commaDelimitedListToStringArray(serviceUrls);
        List&lt;String&gt; eurekaServiceUrls = new ArrayList&lt;&gt;(serviceUrlsSplit.length);
        for (String eurekaServiceUrl : serviceUrlsSplit) {
            if (!endsWithSlash(eurekaServiceUrl)) {
                eurekaServiceUrl += &quot;/&quot;;
            }
            eurekaServiceUrls.add(eurekaServiceUrl);
        }
        return eurekaServiceUrls;
    }

    return new ArrayList&lt;&gt;();
}
</code></pre><p>在获取了Region和Zone信息之后，才开始真正加载Eureka Server的具体地址。它根据传入的参数按一定算法确定加载位于哪一个Zone配置的serviceUrls</p>
<pre><code>int myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);
List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);
</code></pre><p><strong><code>eureka.client.serviceUrl.defaultZone</code>属性可以配置多个，并且需要通过逗号分隔</strong></p>
<h2 id="服务注册原理"><a href="#服务注册原理" class="headerlink" title="服务注册原理"></a>服务注册原理</h2><pre><code>public DiscoveryClient(ApplicationInfoManager applicationInfoManager, final EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args) {
    this(applicationInfoManager, config, args, new Provider&lt;BackupRegistry&gt;() {
        private volatile BackupRegistry backupRegistryInstance;

        @Override
        public synchronized BackupRegistry get() {
            if (backupRegistryInstance == null) {
                String backupRegistryClassName = config.getBackupRegistryImpl();
                if (null != backupRegistryClassName) {
                    try {
                        backupRegistryInstance = (BackupRegistry) Class.forName(backupRegistryClassName).newInstance();
                        logger.info(&quot;Enabled backup registry of type {}&quot;, backupRegistryInstance.getClass());
                    } catch (InstantiationException e) {
                        logger.error(&quot;Error instantiating BackupRegistry.&quot;, e);
                    } catch (IllegalAccessException e) {
                        logger.error(&quot;Error instantiating BackupRegistry.&quot;, e);
                    } catch (ClassNotFoundException e) {
                        logger.error(&quot;Error instantiating BackupRegistry.&quot;, e);
                    }
                }

                if (backupRegistryInstance == null) {
                    logger.warn(&quot;Using default backup registry implementation which does not do anything.&quot;);
                    backupRegistryInstance = new NotImplementedRegistryImpl();
                }
            }

            return backupRegistryInstance;
        }
    });
}
</code></pre><h2 id="服务注册原理-1"><a href="#服务注册原理-1" class="headerlink" title="服务注册原理"></a>服务注册原理</h2><p><code>initScheduledTasks</code></p>
<pre><code>//判断是否应该被发现通过Eureka注册的实例
if (clientConfig.shouldRegisterWithEureka()) {
    ...
    //复制因子
    instanceInfoReplicator = new InstanceInfoReplicator(
                this,
                instanceInfo,
                clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                2);     
    ..
}
</code></pre><p><code>InstanceInfoReplicator</code> </p>
<pre><code>public void run() {
    try {
        discoveryClient.refreshInstanceInfo();

        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();
        if (dirtyTimestamp != null) {
             //真正执行服务注册的地方 
            discoveryClient.register();
            instanceInfo.unsetIsDirty(dirtyTimestamp);
        }
    } catch (Throwable t) {
        logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);
    } finally {
        Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);
        scheduledPeriodicRef.set(next);
    }
}
</code></pre><p><code>register</code></p>
<p>eureka通过rest服务调用</p>
<pre><code>boolean register() throws Throwable {
    logger.info(PREFIX + &quot;{}: registering service...&quot;, appPathIdentifier);
    EurekaHttpResponse&lt;Void&gt; httpResponse;
    try {
        //通过rest进行调用的，同时传入com.netflix.appinfo.InstanceInfo元数据对象
        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);
    } catch (Exception e) {
        logger.warn(PREFIX + &quot;{} - registration failed {}&quot;, appPathIdentifier, e.getMessage(), e);
        throw e;
    }
    if (logger.isInfoEnabled()) {
        logger.info(PREFIX + &quot;{} - registration status: {}&quot;, appPathIdentifier, httpResponse.getStatusCode());
    }
    return httpResponse.getStatusCode() == 204;
}
</code></pre><h2 id="服务获取与服务续约"><a href="#服务获取与服务续约" class="headerlink" title="服务获取与服务续约"></a>服务获取与服务续约</h2><pre><code>if (clientConfig.shouldFetchRegistry()) {
        // registry cache refresh timer
        int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();
        int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
        scheduler.schedule(
                new TimedSupervisorTask(
                        &quot;cacheRefresh&quot;,
                        scheduler,
                        cacheRefreshExecutor,
                        registryFetchIntervalSeconds,
                        TimeUnit.SECONDS,
                        expBackOffBound,
                        new CacheRefreshThread()
                ),
                registryFetchIntervalSeconds, TimeUnit.SECONDS);
    }
</code></pre><p>时间控制参数<code>eureka.instance.lease-renewal-interval-in-seconds=30</code><br>和 <code>eureka.instance.lease-expiration-duration-in-seconds=90</code></p>
<p>服务续约</p>
<pre><code>    boolean renew() {
    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;
    try {
        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
        logger.debug(PREFIX + &quot;{} - Heartbeat status: {}&quot;, appPathIdentifier, httpResponse.getStatusCode());
        if (httpResponse.getStatusCode() == 404) {
            REREGISTER_COUNTER.increment();
            logger.info(PREFIX + &quot;{} - Re-registering apps/{}&quot;, appPathIdentifier, instanceInfo.getAppName());
            long timestamp = instanceInfo.setIsDirtyWithTime();
            boolean success = register();
            if (success) {
                instanceInfo.unsetIsDirty(timestamp);
            }
            return success;
        }
        return httpResponse.getStatusCode() == 200;
    } catch (Throwable e) {
        logger.error(PREFIX + &quot;{} - was unable to send heartbeat!&quot;, appPathIdentifier, e);
        return false;
    }
}
</code></pre><p><a href="http://blog.didispace.com/springcloud-sourcecode-eureka/" target="_blank" rel="external">Eureka源码分析</a></p>
<p><a href="http://xujin.org/sc/sc-netflix-eureka/" target="_blank" rel="external">Eureka架构</a></p>
<p><a href="http://blog.spring-cloud.io/blog/sc-eureka.html" target="_blank" rel="external">Eureka源码排坑处</a></p>
<p><a href="http://nobodyiam.com/2016/06/25/dive-into-eureka/" target="_blank" rel="external">Eureka内部实现细节</a></p>
<p><a href="https://github.com/Netflix/eureka/wiki" target="_blank" rel="external">Eureka官方文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg"
               alt="dzx" />
          <p class="site-author-name" itemprop="name">dzx</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">151</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">115</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dzx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
