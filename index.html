<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="dzxblog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="dzxblog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dzxblog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>dzxblog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">dzxblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/Eureka源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/Eureka源码解析/" itemprop="url">Eureka源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T16:53:44+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SpringBoot注册到EurekaServer服务器列表</p>
<ol>
<li><code>@EnableDiscoveryClient</code> 激活Eureka中的DiscoveryClient实现</li>
<li><code>eureka.client.serviceUrl.defaultZone=http://localhost:10010/eureka/</code> 指定服务器注册中心</li>
</ol>
<h3 id="EnableDiscoveryClient实现"><a href="#EnableDiscoveryClient实现" class="headerlink" title="@EnableDiscoveryClient实现"></a>@EnableDiscoveryClient实现</h3><p>开启DiscoveryClient</p>
<pre><code>/**
 * Annotation to enable a DiscoveryClient implementation.
 * @author Spencer Gibb
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(EnableDiscoveryClientImportSelector.class)
public @interface EnableDiscoveryClient {

}
</code></pre><h3 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h3><p>DiscoveryClient职责</p>
<ol>
<li>向EurekaServer注册服务</li>
<li>向EurekaServer租约续期</li>
<li>当服务器关闭时，取消租约</li>
<li>查询EureServer中的服务列表</li>
<li>EurekaClient需要配置一个EurekaServer URL列表</li>
</ol>
<p>根据配置属性<code>eureka.client.serviceUrl.defaultZone</code>从DiscoveryClient中找到serviceUrl</p>
<pre><code>private final EndpointUtils.ServiceUrlRandomizer urlRandomizer;
</code></pre><p>EndpointUtils中找到<code>getServiceUrlsFromConfig</code>方法</p>
<blockquote>
<p>Get the list of all eureka service urls from properties file for the eureka client to talk to.<br>从配置文件中得到所有eureka的serviceUrl与EurekaClient进行对话</p>
</blockquote>
<p>参数</p>
<ul>
<li>clientConfig clientConfig中使用</li>
<li>instanceZone 客户端所在的Zone</li>
<li>preferSameZone 必须选择与客户端相同的Zone</li>
</ul>
<pre><code>     public static List&lt;String&gt; getServiceUrlsFromConfig(EurekaClientConfig clientConfig, String instanceZone, boolean preferSameZone) {
    List&lt;String&gt; orderedUrls = new ArrayList&lt;String&gt;();
    String region = getRegion(clientConfig);
    String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
    if (availZones == null || availZones.length == 0) {
        availZones = new String[1];
        availZones[0] = DEFAULT_ZONE;
    }
    logger.debug(&quot;The availability zone for the given region {} are {}&quot;, region, availZones);
    int myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);

    List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);
    if (serviceUrls != null) {
        orderedUrls.addAll(serviceUrls);
    }
    int currentOffset = myZoneOffset == (availZones.length - 1) ? 0 : (myZoneOffset + 1);
    while (currentOffset != myZoneOffset) {
        serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[currentOffset]);
        if (serviceUrls != null) {
            orderedUrls.addAll(serviceUrls);
        }
        if (currentOffset == (availZones.length - 1)) {
            currentOffset = 0;
        } else {
            currentOffset++;
        }
    }

    if (orderedUrls.size() &lt; 1) {
        throw new IllegalArgumentException(&quot;DiscoveryClient: invalid serviceUrl specified!&quot;);
    }
    return orderedUrls;
}
</code></pre><p>方法中可以得到两个内容Region、Zone</p>
<pre><code>String region = getRegion(clientConfig);
String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
</code></pre><p>tip：<strong>一个微服务只可以属于一个region</strong>，不特别配置，region和zone值就为default，如果需要自定义可以通过<code>eureka.client.region</code>设置</p>
<pre><code>public static String getRegion(EurekaClientConfig clientConfig) {
    String region = clientConfig.getRegion();
    if (region == null) {
        region = DEFAULT_REGION;
    }
    region = region.trim().toLowerCase();
    return region;
}
</code></pre><p>EurekaClientConfigBean是EurekaClientConfig实现类</p>
<p><code>getAvailabilityZones</code>如果未配置region，会采用默认defaultZone，这就是<code>eureka.client.serviceUrl.defaultZone</code>配置参数的由来</p>
<p>   public String[] getAvailabilityZones(String region) {<br>        String value = this.availabilityZones.get(region);<br>        if (value == null) {<br>            value = DEFAULT_ZONE;<br>        }<br>        return value.split(“,”);<br>    }</p>
<p><strong>Region和Zone之间的关系是一对多关系</strong></p>
<h2 id="ServiceUrls"><a href="#ServiceUrls" class="headerlink" title="ServiceUrls"></a>ServiceUrls</h2><p>具体实现</p>
<pre><code>public List&lt;String&gt; getEurekaServerServiceUrls(String myZone) {
    String serviceUrls = this.serviceUrl.get(myZone);
    if (serviceUrls == null || serviceUrls.isEmpty()) {
        serviceUrls = this.serviceUrl.get(DEFAULT_ZONE);
    }
    if (!StringUtils.isEmpty(serviceUrls)) {
        final String[] serviceUrlsSplit = StringUtils.commaDelimitedListToStringArray(serviceUrls);
        List&lt;String&gt; eurekaServiceUrls = new ArrayList&lt;&gt;(serviceUrlsSplit.length);
        for (String eurekaServiceUrl : serviceUrlsSplit) {
            if (!endsWithSlash(eurekaServiceUrl)) {
                eurekaServiceUrl += &quot;/&quot;;
            }
            eurekaServiceUrls.add(eurekaServiceUrl);
        }
        return eurekaServiceUrls;
    }

    return new ArrayList&lt;&gt;();
}
</code></pre><p>在获取了Region和Zone信息之后，才开始真正加载Eureka Server的具体地址。它根据传入的参数按一定算法确定加载位于哪一个Zone配置的serviceUrls</p>
<pre><code>int myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);
List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);
</code></pre><p><strong><code>eureka.client.serviceUrl.defaultZone</code>属性可以配置多个，并且需要通过逗号分隔</strong></p>
<h2 id="服务注册原理"><a href="#服务注册原理" class="headerlink" title="服务注册原理"></a>服务注册原理</h2><pre><code>public DiscoveryClient(ApplicationInfoManager applicationInfoManager, final EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args) {
    this(applicationInfoManager, config, args, new Provider&lt;BackupRegistry&gt;() {
        private volatile BackupRegistry backupRegistryInstance;

        @Override
        public synchronized BackupRegistry get() {
            if (backupRegistryInstance == null) {
                String backupRegistryClassName = config.getBackupRegistryImpl();
                if (null != backupRegistryClassName) {
                    try {
                        backupRegistryInstance = (BackupRegistry) Class.forName(backupRegistryClassName).newInstance();
                        logger.info(&quot;Enabled backup registry of type {}&quot;, backupRegistryInstance.getClass());
                    } catch (InstantiationException e) {
                        logger.error(&quot;Error instantiating BackupRegistry.&quot;, e);
                    } catch (IllegalAccessException e) {
                        logger.error(&quot;Error instantiating BackupRegistry.&quot;, e);
                    } catch (ClassNotFoundException e) {
                        logger.error(&quot;Error instantiating BackupRegistry.&quot;, e);
                    }
                }

                if (backupRegistryInstance == null) {
                    logger.warn(&quot;Using default backup registry implementation which does not do anything.&quot;);
                    backupRegistryInstance = new NotImplementedRegistryImpl();
                }
            }

            return backupRegistryInstance;
        }
    });
}
</code></pre><h2 id="服务注册原理-1"><a href="#服务注册原理-1" class="headerlink" title="服务注册原理"></a>服务注册原理</h2><p><code>initScheduledTasks</code></p>
<pre><code>//判断是否应该被发现通过Eureka注册的实例
if (clientConfig.shouldRegisterWithEureka()) {
    ...
    //复制因子
    instanceInfoReplicator = new InstanceInfoReplicator(
                this,
                instanceInfo,
                clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                2);     
    ..
}
</code></pre><p><code>InstanceInfoReplicator</code> </p>
<pre><code>public void run() {
    try {
        discoveryClient.refreshInstanceInfo();

        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();
        if (dirtyTimestamp != null) {
             //真正执行服务注册的地方 
            discoveryClient.register();
            instanceInfo.unsetIsDirty(dirtyTimestamp);
        }
    } catch (Throwable t) {
        logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);
    } finally {
        Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);
        scheduledPeriodicRef.set(next);
    }
}
</code></pre><p><code>register</code></p>
<p>eureka通过rest服务调用</p>
<pre><code>boolean register() throws Throwable {
    logger.info(PREFIX + &quot;{}: registering service...&quot;, appPathIdentifier);
    EurekaHttpResponse&lt;Void&gt; httpResponse;
    try {
        //通过rest进行调用的，同时传入com.netflix.appinfo.InstanceInfo元数据对象
        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);
    } catch (Exception e) {
        logger.warn(PREFIX + &quot;{} - registration failed {}&quot;, appPathIdentifier, e.getMessage(), e);
        throw e;
    }
    if (logger.isInfoEnabled()) {
        logger.info(PREFIX + &quot;{} - registration status: {}&quot;, appPathIdentifier, httpResponse.getStatusCode());
    }
    return httpResponse.getStatusCode() == 204;
}
</code></pre><h2 id="服务获取与服务续约"><a href="#服务获取与服务续约" class="headerlink" title="服务获取与服务续约"></a>服务获取与服务续约</h2><pre><code>if (clientConfig.shouldFetchRegistry()) {
        // registry cache refresh timer
        int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();
        int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
        scheduler.schedule(
                new TimedSupervisorTask(
                        &quot;cacheRefresh&quot;,
                        scheduler,
                        cacheRefreshExecutor,
                        registryFetchIntervalSeconds,
                        TimeUnit.SECONDS,
                        expBackOffBound,
                        new CacheRefreshThread()
                ),
                registryFetchIntervalSeconds, TimeUnit.SECONDS);
    }
</code></pre><p>时间控制参数<code>eureka.instance.lease-renewal-interval-in-seconds=30</code><br>和 <code>eureka.instance.lease-expiration-duration-in-seconds=90</code></p>
<p>服务续约</p>
<pre><code>    boolean renew() {
    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;
    try {
        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
        logger.debug(PREFIX + &quot;{} - Heartbeat status: {}&quot;, appPathIdentifier, httpResponse.getStatusCode());
        if (httpResponse.getStatusCode() == 404) {
            REREGISTER_COUNTER.increment();
            logger.info(PREFIX + &quot;{} - Re-registering apps/{}&quot;, appPathIdentifier, instanceInfo.getAppName());
            long timestamp = instanceInfo.setIsDirtyWithTime();
            boolean success = register();
            if (success) {
                instanceInfo.unsetIsDirty(timestamp);
            }
            return success;
        }
        return httpResponse.getStatusCode() == 200;
    } catch (Throwable e) {
        logger.error(PREFIX + &quot;{} - was unable to send heartbeat!&quot;, appPathIdentifier, e);
        return false;
    }
}
</code></pre><p><a href="http://blog.didispace.com/springcloud-sourcecode-eureka/" target="_blank" rel="external">Eureka源码分析</a></p>
<p><a href="http://xujin.org/sc/sc-netflix-eureka/" target="_blank" rel="external">Eureka架构</a></p>
<p><a href="http://blog.spring-cloud.io/blog/sc-eureka.html" target="_blank" rel="external">Eureka源码排坑处</a></p>
<p><a href="http://nobodyiam.com/2016/06/25/dive-into-eureka/" target="_blank" rel="external">Eureka内部实现细节</a></p>
<p><a href="https://github.com/Netflix/eureka/wiki" target="_blank" rel="external">Eureka官方文档</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/Eureka源码解析——项目结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/Eureka源码解析——项目结构/" itemprop="url">Eureka源码解析——项目结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T16:53:09+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Eureka源码解析"><a href="#Eureka源码解析" class="headerlink" title="Eureka源码解析"></a>Eureka源码解析</h1><h2 id="EurekaClient"><a href="#EurekaClient" class="headerlink" title="EurekaClient"></a>EurekaClient</h2><ul>
<li><p><code>com.netflix.appinfo</code> Eureka应用配置文件信息</p>
</li>
<li><p><code>com.netflix.discovery</code> EurekaClient注册与发现相关功能</p>
<ul>
<li><code>EurekaClient</code> 注册发现客户端接口</li>
<li><code>DiscoveryClient</code> 注册发现客户端实现类</li>
<li><a href="https://baike.baidu.com/item/Guice/3227716?fr=aladdin" target="_blank" rel="external"><code>Guice</code></a> 使用Google轻量级IoC依赖注入框架，避免与Spring冲突 <a href="http://www.blogjava.net/xylz/archive/2009/12/22/306955.html" target="_blank" rel="external">Guice入门教程</a></li>
<li><code>converters</code> Eureka 内部传输数据编解码转换器。支持XML和JSON的格式</li>
<li><code>provider</code> 自定义的Jersey 请求和响应的序列化和反序列化实现</li>
<li><code>providers</code> 实现 javax.inject.Provider 接口，设置 EurekaClientConfig (Eureka 客户端配置)的生成工厂 <a href="http://blog.csdn.net/derekjiang/article/details/7231490" target="_blank" rel="external">GoogleGuice入门介绍</a></li>
<li><code>shared</code> EurekaClient 和 EurekaServer 注册发现相关的共享重用的代码</li>
<li><code>util</code> 工具类</li>
<li><code>endpoint</code> 未知</li>
</ul>
</li>
</ul>
<h2 id="EurekaClientArchaius2"><a href="#EurekaClientArchaius2" class="headerlink" title="EurekaClientArchaius2"></a>EurekaClientArchaius2</h2><p><a href="http://blog.csdn.net/zhangfb95/article/details/48297907" target="_blank" rel="external">Archaius是Netflix开源的配置管理组件</a></p>
<h2 id="EurekaClientJersey2"><a href="#EurekaClientJersey2" class="headerlink" title="EurekaClientJersey2"></a>EurekaClientJersey2</h2><p><a href="https://baike.baidu.com/item/Jersey/17577306?fr=aladdin" target="_blank" rel="external">Jersey 是 JAX-RS（JSR311）开源参考实现，用于构建 RESTful WebService</a></p>
<p><a href="http://blog.csdn.net/a19881029/article/details/43056429" target="_blank" rel="external">Jersey基本使用</a></p>
<ul>
<li>EurekaServer 使用 Jersey Server 创建 RESTful Server </li>
<li>EurekaClient 使用 Jersey Client 请求 Eureka-Server </li>
</ul>
<h2 id="EurekaCore"><a href="#EurekaCore" class="headerlink" title="EurekaCore"></a>EurekaCore</h2><ul>
<li><code>com.netflix.eureka</code> 为 Eureka-Server 的功能实现<ul>
<li><code>EurekaBootStrap</code> EurekaServer启动类</li>
<li><code>cluster</code> EurekaServer 集群数据复制相关</li>
<li><code>lease</code> 应用注册后的租约管理( 注册 / 取消 / 续期 / 过期 )</li>
<li><code>resources</code> 基于 Jersey Server 实现，相当于 Spring MVC 的控制层代码</li>
<li><code>transport</code>基于com.netflix.discovery.shared.transport封装实现</li>
</ul>
</li>
</ul>
<h3 id="EurekaResources"><a href="#EurekaResources" class="headerlink" title="EurekaResources"></a>EurekaResources</h3><p>运维后台管理界面</p>
<h2 id="EurekaServer"><a href="#EurekaServer" class="headerlink" title="EurekaServer"></a>EurekaServer</h2><p>打war包:EurekaClient + EurekaCore + EurekaResources</p>
<h3 id="EurekaServerGovernator"><a href="#EurekaServerGovernator" class="headerlink" title="EurekaServerGovernator"></a>EurekaServerGovernator</h3><p><a href="http://www.codeweblog.com/guice-%E6%A1%86%E6%9E%B6%E6%89%A9%E5%B1%95-governator/" target="_blank" rel="external">使用 Netflix Governator 管理 Eureka-Server 的生命周期——governator</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/untitled-1511491947278/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/untitled-1511491947278/" itemprop="url">性能调优——编译优化技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T10:52:27+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>即时编译器JIT：为了提高热点代码执行效率，虚拟机将热点代码编译成本地平台相关机器码，并进行各种层次的优化，完成此任务的编译器就叫即时编译器</p>
<p>什么是热点代码？</p>
<p>热点代码就是程序中频繁执行的方法或者代码块</p>
<p>如何判定热点代码？</p>
<p>基于采样的热点探测：周期性的检查各个线程中的栈顶，某些代码（方法）经常出现于栈顶，就属于热点代码</p>
<p>该方法的优缺点？<br>优点：获取方法之间调用关系（通过堆栈展开）<br>缺点：无法精确到具体热度，容易受线程阻塞等外界因素扰乱热点探测</p>
<p>基于计数器的热点探测：为每个方法（代码块）设置计数器，统计执行次数，执行次数超过一定阈值就被认为是热点方法</p>
<p>该方法的优缺点？<br>优点：可以获取精确热度<br>缺点：需要为每个方法建立计数器，不能获取方法之间具体调用关系</p>
<p>Tips: HotSpot虚拟机基于计数器探测方法(方法调用计数器和回边计数器)。</p>
<p>计数器超过一定阈值就会触发JIT编译</p>
<p>默认阈值Client模式下是1500次，Server模式下是10000。可以通过-XX:CompileThresold和-XX :BackEdgeThresold进行设置。还可通过-XX:OnStackReplacePercentage间接设置</p>
<p>计算公式：</p>
<p>虚拟机在Client模式下：</p>
<p>回边计数器阈值计算公式 = 方法调用计数器阈值 * OSR比率(OnStackReplacePercentage) / 100</p>
<p>OnStackReplacePercentage默认值933。 都取默认值的情况下，阈值为13995</p>
<p>虚拟机在Server模式下：</p>
<p>回边计数器阈值计算公式 = 方法调用计数器阈值 * OSR比率(OnStackReplacePercentage) - 解释器监控比率（InterpreterProfilePercentage） / 100</p>
<p>OnStackReplacePercentage默认值140。 InterpreterProfilePercentage默认值33，都取默认值的情况下，阈值为10700</p>
<p>编译过程</p>
<p>JVM参数</p>
<p>-XX:printCompilation 要求虚拟机在JIT时将编译成本地代码的方法名称打印出来</p>
<p>-XX:+PrintCFGToFile<br>-XX:PrintIdealGraphFile<br>将虚拟机各个级段的数据输出到文件</p>
<p>-XX:CompileThresold<br>-XX :BackEdgeThresold<br>-XX:OnStackReplacePercentage</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/untitled-1511491469418/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/untitled-1511491469418/" itemprop="url">性能调优——线程安全和锁优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T10:44:29+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深入虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">深入虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程安全的概念"><a href="#线程安全的概念" class="headerlink" title="线程安全的概念"></a>线程安全的概念</h2><p>通过搜索引擎搜索出来的结果是：“一个变量可以安全的被多个线程同时使用，就是线程安全的”。这样的描述并不准确。有一个更恰当的定义</p>
<p>“当多线程访问同一个对象，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是安全的</p>
<h2 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h2><p>线程安全的前提是：存在多个线程之间对共享数据进行访问。如果不与其他线程共享数据，那他是串行执行或者多线程执行是没有区别的。</p>
<p>Java共享数据类型：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p>
<p>不可变对象一定是线程安全的。final修饰来声明不可变对象</p>
<p>java.lang.String是一个不可变对象，通过对字符串进行任何操作，构造出来的也是一个新字符串，而不会影响原来的值</p>
<p>不可变对象：java.lang.Number部分子类（Long和Double、BigDecimal和BigInteger）、枚举类型</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步：最常见的一种并发正确性保障手段"><a href="#互斥同步：最常见的一种并发正确性保障手段" class="headerlink" title="互斥同步：最常见的一种并发正确性保障手段"></a>互斥同步：最常见的一种并发正确性保障手段</h3><p>“同步指在多个线程并发访问共享数据情况下，保障共享数据只能在同一时刻只被一条线程使用。互斥是实现同步的一种手段。互斥实现方式：临界区、互斥量和信号量</p>
<p>最基本的互斥同步是synchronized关键字。产生monitorenter和monitorexit两个字节码，需要一个reference类型参数锁定和解锁对象。如果没有指定类型参数，默认就是当前实例作为同步对象</p>
<p>synchronized执行原理：根据虚拟机规范，在执行monitorenter指令时，首先要去尝试获取对象的锁，如果对象并未锁定，或者当前线程已经拥有该对象的锁，把锁的计数器+1.相应的，monitorexit指令时将锁计数器减1，当计数器为0时，锁被释放。如果获取锁对象失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放</p>
<p>tips：synchronized同步块对同一条线程时可重入的，不会出现把自己锁死的情况。<br>同步块在已进入线程执行完之前，会阻塞后面其他线程的进入。<br>所以被synchronized修饰的方法getter/setter方法，消耗时间比较长，所以在Java中称为重量级锁。<br>除了重量级锁，可以引用java.util.concurrent中的轻量级锁ReentrantLock实现同步。都可以实现线程重入。但是lock()和unlock()需要配合try{}finally{}模块完成，还新增几个功能：等待可中断、实现公平锁以及锁绑定多个条件</p>
<p>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情<br>公平锁：多个线程申请同一个锁时，必须按照申请锁的时间顺序来获取锁；而非公平锁不能保证，在锁被释放时，任何一个等待锁的线程都有机会获取锁。synchronized和ReentrantLock是非公平锁<br>锁绑定多个条件：一个ReentrantLock对象可以绑定多个Condition对象，多次调用newCondition()方法。而在synchronized中需要额外多加锁才能实现</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>非同步方案</p>
<p>可重入代码：可在代码的任何时刻中断，转而去执行另外一段代码。</p>
<p>如何判断代码是否具有可重入性:一个方法，返回结果是可预测的，只要输入相同的数据，返回相同的结果。具备可重入性线程就是安全的</p>
<h2 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h2><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>常见的锁优化技术：适应式自旋、锁消除、锁粗化、轻量级锁和偏向锁等</p>
<p>自旋锁<br>JDK1.6默认开启自旋锁。或者通过-XX:+UseSpinning开启。自旋次数默认10次 可以通过 -XX: PreBlockSpin参数更改</p>
<p>锁消除<br>指在JIT运行时候，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</p>
<p>锁消除主要依据：来源于逃逸分析的数据支持</p>
<p>锁粗化</p>
<p>轻量级锁</p>
<p>重量级锁</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/MySQL处理海量数据架构优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/MySQL处理海量数据架构优化/" itemprop="url">MySQL处理海量数据架构优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-24T13:38:39+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/优化/" itemprop="url" rel="index">
                    <span itemprop="name">优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL处理海量数据架构优化"><a href="#MySQL处理海量数据架构优化" class="headerlink" title="MySQL处理海量数据架构优化"></a>MySQL处理海量数据架构优化</h1><h2 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h2><ol>
<li>业务分流</li>
<li>SQL语句优化</li>
</ol>
<h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><ol>
<li>分表分库</li>
<li>读写分离</li>
<li>数据缓存</li>
</ol>
<h2 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h2><ol>
<li>硬件配置</li>
</ol>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><ol>
<li>引擎选择</li>
<li>逻辑改造</li>
<li>索引</li>
</ol>
<h2 id="Mysql处理海量数据架构优化三大方法：分表分库，读写分离，数据缓存"><a href="#Mysql处理海量数据架构优化三大方法：分表分库，读写分离，数据缓存" class="headerlink" title="Mysql处理海量数据架构优化三大方法：分表分库，读写分离，数据缓存"></a>Mysql处理海量数据架构优化三大方法：分表分库，读写分离，数据缓存</h2><h3 id="分表分库"><a href="#分表分库" class="headerlink" title="分表分库"></a>分表分库</h3><blockquote>
<p>根据某些条件把大数据分割成多个块，把每个块存放在不同的数据库（数据表中）。<strong>该方法是提高性能的最有效的方法</strong></p>
</blockquote>
<h4 id="根据业务拆分（垂直拆分）"><a href="#根据业务拆分（垂直拆分）" class="headerlink" title="根据业务拆分（垂直拆分）"></a>根据业务拆分（垂直拆分）</h4><p>模拟情景：<br>做一个系统包含模块资讯(New)、博客(Blog)、论坛(Bar)。</p>
<p>问题：论坛数据猛增，访问压力变大<br>解决：将存放Bar数据的数据库进行分库</p>
<p>问题：论坛帖子数量持续增长，访问吃力<br>解决：继续将存放帖子的数据库进行拆分<br>水平拆分：<br>将帖子数据拆分成12个数据库，妹三个数据存放到一台数据库服务器中</p>
<p>问题：单个数据库db1中单表数据量过大<br>解决：db1中进行分表</p>
<p><strong>垂直才分也叫行拆分（Row Splitting），就是把组成一行的多个列分开放到不同的数据库（数据表）中，这些表具有不同的结构。垂直分表就是“业务拆分”</strong></p>
<p><strong>水平拆分：水平拆分就是把一个表分成多个表，每个表的结构一样，但是储存的数据不一样。</strong></p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>对存放帖子的数据库服务器Server2_1_1进行读写分离</p>
<p><strong>Mysql的读写分离是通过Mysql代理实现的，Mysql代理是介于Mysql客户端和Mysql服务器之间的简单程序，用来分析或者传输他们之间的通讯，最大的优点就是：读写分离。</strong></p>
<h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><p>到现在论坛已经可以很好地支持海量数据的存储了。但是我们发现系统的资讯模块有访问吃力。我们在资讯模块添加缓存服务器。</p>
<p>访客首先访问缓存服务器，因为缓存服务器的数据都是在内存当中所以速度会很快，如果缓存中找不到数据再去Server1中查找数据，并且把数据缓存到缓存服务器中</p>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul>
<li>至少要有一个热备</li>
<li>UPS</li>
<li>做合适的RAID。RAID0＋1，RAID5或者RAID6</li>
<li>使用xfs而不是ext3</li>
<li>将数据库数据放入盘柜。更安全，访问更快</li>
<li>使用64位系统</li>
<li>innodb适合写频繁的表，myisam适合读频繁的表</li>
<li>建立正确的索引</li>
<li>优化my.cnf里面的参数。主要关心和buffer有关的参数</li>
<li>打开slow_query_log选项。解决出现的慢查询语句。</li>
<li>使用SAS而不是SATA。数据库对硬盘要求很高</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://www.voidcn.com/article/p-dwtorcpy-gq.html" target="_blank" rel="external">MySQL处理海量数据架构优化</a></p>
<p><a href="http://www.voidcn.com/article/p-enfwbfpp-bds.html" target="_blank" rel="external">MySQL其他优化内容</a></p>
<p><a href="http://www.voidcn.com/article/p-dglyljfd-kx.html" target="_blank" rel="external">SQL语句优化</a></p>
<p><a href="http://www.voidcn.com/article/p-sjgbshdc-bb.html" target="_blank" rel="external">MySQL索引</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/19/微服务架构下处理分布式事务的典型方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/微服务架构下处理分布式事务的典型方案/" itemprop="url">微服务架构下处理分布式事务的典型方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T14:40:57+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="传统数据库事务特性ACID"><a href="#传统数据库事务特性ACID" class="headerlink" title="传统数据库事务特性ACID"></a>传统数据库事务特性ACID</h1><ol>
<li>原子性（atomicity）：事务是数据库的逻辑工作单位，而且是必须是原子工作单位，对于其数据修改，要么全部执行，要么全部不执行。</li>
<li>一致性（consistency）：事务在完成时，必须是所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。</li>
<li>隔离性（isolation）：一个事务的执行不能被其他事务所影响。</li>
<li>持久性（durability）：一个事务一旦提交，事物的操作便永久性的保存在DB中。即使此时再执行回滚操作也不能撤消所做的更改。</li>
</ol>
<h2 id="分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案"><a href="#分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案" class="headerlink" title="分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案"></a>分布式事务的讨论主要聚焦于强一致性和最终一致性的解决方案</h2><ol>
<li>两阶段提交（2PC) 和 三阶段提交(3PC)、paxos算法</li>
<li>eBay事件队列方案</li>
<li>TCC 补偿模式</li>
<li>缓存数据最终一致性</li>
</ol>
<p>一般单机应用采用<a href="http://www.cnblogs.com/azhqiang/p/4044127.html" target="_blank" rel="external">JavaJDBC事务</a>控制即可</p>
<pre><code>try {  
    conn.setAutoCommit(false); 
    //业务代码
    conn.commit();      
} catch (Exception e) {  
    conn.rollback();    
    e.printStackTrace();  
} 
</code></pre><h1 id="分布式数据一致性"><a href="#分布式数据一致性" class="headerlink" title="分布式数据一致性"></a>分布式数据一致性</h1><p>为了保证数据高可用，数据会存放在多个副本（replica）不同物理机器中，需要把保持这些数据的一致性，采用了常用的几种算法<strong>二阶提交(2PC)、三阶提交(3PC)</strong>和<strong>Paxos算法</strong></p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a><a href="http://blog.jobbole.com/95632/" target="_blank" rel="external">分布式事务</a></h1><blockquote>
<p>指会涉及到操作多个数据库的事务。目的是为了保证分布式系统中的数据一致性。</p>
</blockquote>
<p>分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</p>
<p>由于存在事务机制，可以保证每个独立节点的ACID，但是不能知道其他节点的执行情况，所以不能保证数据一致。要想多台机器的数据一致。必须保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。解决方案就是通过<strong>引入一个“协调者”的组件来统一调度所有分布式节点的执行。</strong></p>
<h1 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h1><p>X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分。</p>
<blockquote>
<p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</p>
</blockquote>
<p>二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。<br><strong>两阶段提交主要保证了分布式事务的原子性</strong></p>
<h1 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h1><blockquote>
<p>所谓的两个阶段是指：<strong>准备阶段和提交阶段</strong>。</p>
</blockquote>
<p>两阶段提交算法思路：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong></p>
<p>但是两阶段提交可能出现一些问题：<strong>同步阻塞、单点故障、数据不一致等问题</strong></p>
<p>二阶段无法解决：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交</p>
<h1 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h1><blockquote>
<p>在2PC基础上，新增超时机制和在第一阶段和第二阶段中插入一个准备阶段。</p>
</blockquote>
<p>保证了在最后提交阶段之前各参与节点的状态是一致的（CanCommit阶段、PreCommit阶段、doCommit阶段）</p>
<h1 id="2PC与3PC的区别"><a href="#2PC与3PC的区别" class="headerlink" title="2PC与3PC的区别"></a>2PC与3PC的区别</h1><ol>
<li>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit</li>
<li>3PC也可能导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况</li>
</ol>
<h2 id="一致性理论"><a href="#一致性理论" class="headerlink" title="一致性理论"></a>一致性理论</h2><blockquote>
<p>分布式最终目的是保障分库数据一致，但是会由于各种外界因素，而导致不可控因素（例如：个别节点永久性宕机、无法已知各个节点的事务状态。</p>
<p>2PC是分布式事务较为经典的方案，但是扩展性极差。eBay架构师提出了BASE理论为了<strong>解决大规模分布式系统下的数据一致性问题</strong>。BASE理论：<strong>可以通过放弃系统在每个时刻的强一致性来换取系统的可扩展性。</strong></p>
</blockquote>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><blockquote>
<p>在分布式系统中，一致性（Consistency）、可用性（Availability）和<strong>分区容忍性（Partition Tolerance</strong>3个要素最多只能同时满足两个。</p>
</blockquote>
<ul>
<li>一致性：分布式环境下多个节点的数据是否强一致。</li>
<li>可用性：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果。</li>
<li>分区容忍性：特指对网络分区的容忍性。</li>
</ul>
<p><img src="http://spider.nosdn.127.net/2a517d9dd2583d9fc082f2cc950d838c.png" alt=""></p>
<p>举例：Cassandra、Dynamo等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ul>
<li><strong>基本可用（Basically Available）</strong>：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。</li>
<li><strong>软状态（Soft State）</strong>：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。</li>
<li><strong>最终一致性（Eventual Consistency）</strong>：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。</li>
</ul>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><ul>
<li><strong>强一致性</strong>：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。</li>
<li><strong>弱一致性</strong>：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</li>
<li><strong>最终一致性</strong>：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。
　　</li>
</ul>
<blockquote>
<p>分布式系统数据的强一致性、弱一致性和最终一致性可以通过Quorum NRW算法分析。</p>
</blockquote>
<h2 id="eBay-事件队列方案——最终一致性"><a href="#eBay-事件队列方案——最终一致性" class="headerlink" title="eBay 事件队列方案——最终一致性"></a>eBay 事件队列方案——最终一致性</h2><h3 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h3><blockquote>
<p>将需要分布式处理的任务通过<strong>消息或者日志的方式来异步执行</strong>，消息或日志可以存到<strong>本地文件、数据库或消息队列</strong>，再通过<strong>业务规则进行失败重试</strong>，它要求各服务的接口是幂等</p>
</blockquote>
<p>具体业务场景：</p>
<p>用户表user 和交易表transaction，用户表存储用户信息、总销售额和总购买额，交易表存储每一笔交易的流水号、买家信息、卖家信息和交易金额。如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额</p>
<p><img src="http://spider.nosdn.127.net/a5f15918aceb6e93bdb57af337b3f6d3.png" alt=""></p>
<p>提出的解决方法是将更新交易表记录和用户表更新消息放在一个本地事务来完成</p>
<p>为了避免重复消费用户表更新消息带来的问题，增加一个操作记录表updates_applied来记录已经完成的交易相关的信息</p>
<p><img src="http://spider.nosdn.127.net/312ab5a124e68a2bcc41a28314a813f4.png" alt=""></p>
<h2 id="TCC-（Try-Confirm-Cancel）补偿模式——最终一致性"><a href="#TCC-（Try-Confirm-Cancel）补偿模式——最终一致性" class="headerlink" title="TCC （Try-Confirm-Cancel）补偿模式——最终一致性"></a>TCC （Try-Confirm-Cancel）补偿模式——最终一致性</h2><p><img src="http://spider.nosdn.127.net/1923ecc60ac01aeb99aac67023490929.jpeg" alt=""></p>
<blockquote>
<p>服务A 需要依次调用服务B、服务C 和服务D 共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke 操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的</p>
</blockquote>
<h3 id="实现关键要素"><a href="#实现关键要素" class="headerlink" title="实现关键要素"></a>实现关键要素</h3><p>1.服务调用链必须被记录下来；<br>2.每个服务提供者都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等；<br>3.必须按失败原因执行不同的回滚策略。</p>
<h3 id="实现难点"><a href="#实现难点" class="headerlink" title="实现难点"></a>实现难点</h3><ol>
<li>补偿模式的特点是实现简单，但是想形成一定程度的通用方案比较困难，特别是服务链的记录，因为大部分时候，业务参数或者业务逻辑千差万别。</li>
<li>很多业务特征使得该服务无法提供一个安全的回滚操作。</li>
</ol>
<h2 id="缓存数据最终一致性"><a href="#缓存数据最终一致性" class="headerlink" title="缓存数据最终一致性"></a>缓存数据最终一致性</h2><p>在具体业务系统中，缓存通常被用在数据库前面，作为数据读取的缓冲，使得I/O 操作不至于直接落在数据库上</p>
<p>###缓存和数据库数据不一致的问题解决方案</p>
<ol>
<li><strong>为缓存数据设置过期时间</strong>。当缓存中数据过期后，业务系统会从数据库中获取数据，并将新值放入缓存。这个过期时间就是系统可以达到最终一致的容忍时间</li>
<li><strong>更新数据库数据后同时清除缓存数据。</strong>数据库数据更新后，同步删除缓存中数据，使得下次对商品详情的获取直接从数据库中获取，并同步到缓存</li>
</ol>
<h4 id="分布式事务具体实例"><a href="#分布式事务具体实例" class="headerlink" title="分布式事务具体实例"></a><a href="http://blog.jobbole.com/110805/" target="_blank" rel="external">分布式事务具体实例</a></h4><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/u014403546/article/details/54924054" target="_blank" rel="external">分布式系统事务一致性到CAP,BASE理论</a></p>
<p><a href="https://www.qcloud.com/community/article/120564" target="_blank" rel="external">企鹅讲解分布式事务</a></p>
<p><a href="http://dy.163.com/v2/article/detail/CTR51LFC0518DLIO.html" target="_blank" rel="external">网易云分布式架构解决方案</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/Linux-CPU-load/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/13/Linux-CPU-load/" itemprop="url">Linux CPU load</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T13:43:25+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Load-Average-平均负载-基本概念"><a href="#Load-Average-平均负载-基本概念" class="headerlink" title="Load Average(平均负载)基本概念:"></a>Load Average(平均负载)基本概念:</h2><ul>
<li>Load 指的是运行队列(run-queue)的长度：L = 等待进程的数目 + 运行进程的数目</li>
<li>Load Average指的是在一段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信息，也就是CPU使用队列的长度的统计信息。</li>
<li>Load Average反映了CPU的使用情况和申请情况.</li>
</ul>
<h2 id="Load-Average-平均负载-和CPU占用率的区别"><a href="#Load-Average-平均负载-和CPU占用率的区别" class="headerlink" title="Load Average(平均负载)和CPU占用率的区别:"></a>Load Average(平均负载)和CPU占用率的区别:</h2><ul>
<li>Load Average所包含的信息不是CPU的使用率状况</li>
<li>多任务环境下，系统分配时间片以后，是否使用完全使用时间片取决于进程，因此完全  可能出现低CPU利用率而高Load Average的情况</li>
</ul>
<h2 id="Load-Average的计算"><a href="#Load-Average的计算" class="headerlink" title="Load Average的计算:"></a>Load Average的计算:</h2><p>在多处理器系统中，负载阀值是基于内核的数量决定的。以 100% 负载计算，1.00 表示单个处理器，而 2.00 则说明有两个双处理器，那么 4.00 就说明主机具有四个处理器。超过这个阀值就表示系统过载了</p>
<h2 id="Load-Average的实时计算公式"><a href="#Load-Average的实时计算公式" class="headerlink" title="Load Average的实时计算公式:"></a>Load Average的实时计算公式:</h2><p>load(t) = load(t-1) e^(-5/60) + n (1 - e^(-5/60))，迭代计算，其中n为run-queue的长度</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.chinaunix.net/uid-25793640-id-3202955.html" target="_blank" rel="external">查看Linux负载命令uptime参数详解</a></p>
<p><a href="http://www.cnblogs.com/lddbupt/p/5779655.html" target="_blank" rel="external">CPU load过高排查</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/12/【源码解析】JDK1-8——HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/12/【源码解析】JDK1-8——HashMap/" itemprop="url">【源码解析】JDK1.8——HashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-12T11:37:17+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><pre><code>    public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
implements Map&lt;K,V&gt;, Cloneable, Serializable
</code></pre><ul>
<li>实现Cloneable接口：重写clone()方法，实现浅拷贝</li>
<li><p>实现Serializable接口：HashMap对象可以被序列化</p>
<pre><code>public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;
</code></pre></li>
</ul>
<blockquote>
<p>注：在语法层面继承接口Map是多余的，仅仅起到一个文档作用</p>
</blockquote>
<h1 id="AbstractMap抽象类"><a href="#AbstractMap抽象类" class="headerlink" title="AbstractMap抽象类"></a>AbstractMap抽象类</h1><h2 id="如何实现不可变Map"><a href="#如何实现不可变Map" class="headerlink" title="如何实现不可变Map"></a>如何实现不可变Map</h2><blockquote>
<p>只需继承AbstractMap，然后实现其entrySet方法，这个方法返回的set不支持add与remove，同时这个set的迭代器（iterator）不支持remove操作即可。</p>
</blockquote>
<h2 id="如何实现可变Map"><a href="#如何实现可变Map" class="headerlink" title="如何实现可变Map"></a>如何实现可变Map</h2><blockquote>
<p>首先继承AbstractMap，然后重写（override）AbstractMap的put方法，同时实现entrySet所返回set的迭代器的remove方法即可</p>
</blockquote>
<h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>HashMap基于哈希表实现</p>
<blockquote>
<p>哈希表：叫做关联数组，通用的数据结构。其概念<strong>key经过hash函数作用后得到一个槽（buckets或slots）的索引（index），槽中保存着我们想要获取的值</strong></p>
</blockquote>
<p> <strong>注意：哈希表不同的key经过同一hash函数后可能产生相同的索引（冲突）</strong></p>
<p>HashMap如何避免冲突</p>
<h1 id="HashMap特性"><a href="#HashMap特性" class="headerlink" title="HashMap特性"></a>HashMap特性</h1><ul>
<li>线程非安全，允许key与value都为null值，HashTable与之相反</li>
<li>无序</li>
<li>put、get操作的<strong>时间复杂度为O(1)</strong></li>
<li>遍历其集合视角的<strong>时间复杂度与其容量（capacity）和现有元素的大小（entry）成正比</strong></li>
<li>多个线程同时对一hashmap的集合试图做迭代时有结构的上改变（增加、删除），会报<strong>ConcurrentModificationException</strong>，专业术语叫fail-fast</li>
<li><strong>Map map = Collections.synchronizedMap(new HashMap(…));</strong>得到线程安全的Map</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>//容量必须为2的指数倍（默认为16） (??参考HashMap中哈希函数的设计原理??)
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4；
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
//默认3/4。过高的因子会降低存储空间但是查找新增方法的时间会增加。
static final float DEFAULT_LOAD_FACTOR = 0.75f;

public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                           initialCapacity);
    //容量有最大值
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    //平衡因子和容量因子都有默认值
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
public HashMap(int initialCapacity)
</code></pre><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>在JDK1.6中采用位桶+链表的形式，而JDK1.8采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树。节省了查找时间</p>
<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;
        //hash值、键、值、下一个节点
        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + &quot;=&quot; + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }
        //判断两个节点是否相等
        public final boolean equals(Object o) {
            //与自身比较返回true
            if (o == this)
                return true; 
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
</code></pre><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><pre><code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
   TreeNode&lt;K,V&gt; parent;  // 父节点
   TreeNode&lt;K,V&gt; left; //左树节点
   TreeNode&lt;K,V&gt; right; //右树节点
   TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
   boolean red; //颜色属性 red=true blank=false

   TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
       super(hash, key, val, next);
   }
   //返回当前节点的根节点
   final TreeNode&lt;K,V&gt; root() {
       for (TreeNode&lt;K,V&gt; r = this, p;;) {
           if ((p = r.parent) == null)
               return r;
           r = p;
       }
   }

   static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) {
       int n;
       if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) {
           int index = (n - 1) &amp; root.hash;
           TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];
           if (root != first) {
               Node&lt;K,V&gt; rn;
               tab[index] = root;
               TreeNode&lt;K,V&gt; rp = root.prev;
               if ((rn = root.next) != null)
                   ((TreeNode&lt;K,V&gt;)rn).prev = rp;
               if (rp != null)
                   rp.next = rn;
               if (first != null)
                   first.prev = root;
               root.next = first;
               root.prev = null;
           }
           assert checkInvariants(root);
       }
   }
</code></pre><h2 id="位桶"><a href="#位桶" class="headerlink" title="位桶"></a>位桶</h2><pre><code>transient Node&lt;K,V&gt;[] table;
</code></pre><h1 id="HashMap的具体实现"><a href="#HashMap的具体实现" class="headerlink" title="HashMap的具体实现"></a>HashMap的具体实现</h1><p>有一个每一元素都是链表的数组，添加key-value时，计算key-value的hash值，确定插入数组位置，可能存在每个hash值得元素被放在同一数组位置，添加到同一hash值的元素的后面。</p>
<p>当链表长度太长时，链表就转换为红黑树。增大转换效率</p>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><pre><code> final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    //hash &amp; (length-1)得到对象的保存位  
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            //如果第一个节点是TreeNode,说明采用的是数组+红黑树结构处理冲突  
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            //链表结构处理 (放在相同哈希值的元素之后位置)
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre><h1 id="putval"><a href="#putval" class="headerlink" title="putval"></a>putval</h1><pre><code> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    //如果tab为空或长度为0，则分配内存resize()  
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //(n - 1) &amp; hash找到put位置，如果为空,则直接put  
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        //第一节节点hash值同，且key值与插入key相同  
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode) //红黑树处理冲突  
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else { //链表处理冲突  
            for (int binCount = 0; ; ++binCount) {
                //p第一次指向表头,以后依次后移  
                if ((e = p.next) == null) {
                    //e为空，表示已到表尾也没有找到key值相同节点，则新建节点  
                    p.next = newNode(hash, key, value, null);
                    //新增节点后如果节点个数到达阈值，则将链表转换为红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                 //更新hash值和key值均相同的节点Value值  
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre><h1 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h1><p> 在多线程环境下，假设有容器map，其存储的情况如下图所示（淡蓝色为已有数据）。</p>
<p><img src="http://img.blog.csdn.net/20160505174455202" alt=""></p>
<p>此时的map已经达到了扩容阈值12（16 * 0.75 = 12），而此时线程A与线程B同时对map容器进行插入操作，那么都需要扩容。此时可能出现的情况如下：线程A与线程B都进行了扩容，此时便有两个新的table，那么再赋值给原先的table变量时，便会出现其中一个newTable会被覆盖，假如线程B扩容的newTable覆盖了线程A扩容的newTable，并且是在A已经执行了插入操作之后，那么就会出现线程A的插入失效问题，也即是如下图中的两个table只能有一个会最后存在，而其中一个插入的值会被舍弃的问题。</p>
<p><img src="http://img.blog.csdn.net/20160505174914780" alt=""></p>
<p>这便是HashMap的线程不安全性，当然这只是其中的一点。而要消除这种隐患，则可以加锁或使用HashTable和ConcurrentHashMap这样的线程安全类，但是HashTable不被建议使用，推荐使用ConcurrentHashMap容器</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p> <a href="http://blog.csdn.net/u010498696/article/details/45888613" target="_blank" rel="external">http://blog.csdn.net/u010498696/article/details/45888613</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/09/【HK】搜索引擎语法——GoogleHack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/09/【HK】搜索引擎语法——GoogleHack/" itemprop="url">【HK】搜索引擎语法——GoogleHack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-09T14:00:49+08:00">
                2017-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/黑客/" itemprop="url" rel="index">
                    <span itemprop="name">黑客</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="intitle"><a href="#intitle" class="headerlink" title="intitle:"></a>intitle:</h1><blockquote>
<p>搜索指定标题内容的网页</p>
</blockquote>
<h1 id="Site"><a href="#Site" class="headerlink" title="Site:"></a>Site:</h1><blockquote>
<p>显示所有与目标网站有联系的页面（常用来做入侵前的信息试探）</p>
</blockquote>
<h1 id="filetype"><a href="#filetype" class="headerlink" title="filetype:"></a>filetype:</h1><blockquote>
<p>搜索网站的数据库文件</p>
</blockquote>
<h1 id="intext"><a href="#intext" class="headerlink" title="intext:"></a>intext:</h1><blockquote>
<p>搜索目标网页含有特定字符的网页</p>
</blockquote>
<h1 id="cache"><a href="#cache" class="headerlink" title="cache:"></a>cache:</h1><blockquote>
<p>搜索指定内容的缓存</p>
</blockquote>
<h1 id="define"><a href="#define" class="headerlink" title="define:"></a>define:</h1><blockquote>
<p>搜索特定词语的定义</p>
</blockquote>
<h1 id="inurl"><a href="#inurl" class="headerlink" title="inurl"></a>inurl</h1><blockquote>
<p>搜索指定字符是否存在url中</p>
</blockquote>
<h1 id="link"><a href="#link" class="headerlink" title="link:"></a>link:</h1><blockquote>
<p>返回用目标地址作链接的所有网页</p>
</blockquote>
<h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li>+把google可能忽略的字列如查询范围</li>
<li>-把某个字忽略</li>
<li>~同意词</li>
<li>.单一的通配符</li>
<li>*通配符，可代表多个字母</li>
<li>“ “精确查询</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.williamlong.info/archives/150.html" target="_blank" rel="external">http://www.williamlong.info/archives/150.html</a></p>
<h1 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h1><p><a href="https://en.wikipedia.org/wiki/Google_hacking" target="_blank" rel="external">https://en.wikipedia.org/wiki/Google_hacking</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/【代码规范】Google代码规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dzxblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/【代码规范】Google代码规范/" itemprop="url">【代码规范】Google代码规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T10:04:08+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范/" itemprop="url" rel="index">
                    <span itemprop="name">代码规范</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><blockquote>
<p>源文件以其最顶层的类名来命名，大小写敏感。例如：包名为com.bcw.ewms，文件名设置为ewms</p>
</blockquote>
<h2 id="统一文件编码UTF-8"><a href="#统一文件编码UTF-8" class="headerlink" title="统一文件编码UTF-8"></a>统一文件编码UTF-8</h2><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><pre><code>- **空白字符**:除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符
- **特殊转义序列**:对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, &quot;, &apos;及\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。
- **非ASCII字符**:对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。
</code></pre><p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释</p>
<pre><code>`
      String unitAbbrev = &quot;μs&quot;;                                 | 赞，即使没有注释也非常清晰
      String unitAbbrev = &quot;\u03bcs&quot;; // &quot;μs&quot;                    | 允许，但没有理由要这样做
      String unitAbbrev = &quot;\u03bcs&quot;; // Greek letter mu, &quot;s&quot;    | 允许，但这样做显得笨拙还容易出错
          String unitAbbrev = &quot;\u03bcs&quot;;                            | 很糟，读者根本看不出这是什么
          return &apos;\ufeff&apos; + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释
`
</code></pre><h2 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h2><ol>
<li>许可证或版权信息(如有需要)</li>
<li>package语句</li>
<li>import语句<blockquote>
<p> import不要使用通配符。例如：import java.util.*;</p>
</blockquote>
</li>
<li>一个顶级类(只有一个)</li>
</ol>
<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><ol>
<li>只有一个顶级类声明<blockquote>
<p>每个顶级类都在一个与它同名的源文件中</p>
</blockquote>
</li>
<li>类成员顺序<blockquote>
<p>每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。</p>
</blockquote>
</li>
<li>重载：永不分离<blockquote>
<p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
</blockquote>
</li>
</ol>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ol>
<li>大括号<blockquote>
<p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
</blockquote>
</li>
<li><p>非空块：K &amp; R 风格</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。 </li>
</ul>
</li>
<li><p>空块 </p>
<pre><code>void doNothing() {}
</code></pre></li>
<li><p>每个语句后要换行。      </p>
</li>
<li><p>列限制：80或100字符</p>
</li>
<li><p>断开</p>
<ol>
<li>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<t extends="" foo="" &="" bar="">)，catch块中的管道符号(catch (FooException | BarException e)</t></li>
<li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。】</li>
</ol>
</li>
<li><p>自动换行时缩进至少+4个空格</p>
</li>
</ol>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><ol>
<li>水平空白</li>
<li>垂直空白</li>
<li>水平对齐</li>
</ol>
<h2 id="用小括号来限定组"><a href="#用小括号来限定组" class="headerlink" title="用小括号来限定组"></a>用小括号来限定组</h2><h2 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h2><ol>
<li><p>枚举</p>
<blockquote>
<p>枚举常量间用逗号隔开，换行可选。</p>
</blockquote>
</li>
<li><p>每次只声明一个变量</p>
</li>
<li><p>需要时才声明，并尽快进行初始化</p>
</li>
<li><p>数组</p>
<ol>
<li>数组初始化：可写成块状结构</li>
<li>非C风格的数组声明:中括号是类型的一部分：String[] args， 而非String args[]。</li>
</ol>
</li>
<li><p>switch语句<br> 1.switch块中的内容缩进为2个空格。<br> 2.在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现</p>
</li>
<li><p>注解(Annotations)</p>
<blockquote>
<p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。</p>
</blockquote>
</li>
</ol>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li>块注释风格<blockquote>
<p>块注释与其周围的代码在同一缩进级别。它们可以是/<em> … </em>/风格，也可以是// …风格。对于多行的/<em> … </em>/注释，后续行必须从<em>开始， 并且与前一行的</em>对齐</p>
</blockquote>
</li>
</ol>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><ol>
<li><p>对所有标识符都通用的规则</p>
<blockquote>
<p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p>
</blockquote>
</li>
<li><p>标识符类型的规则</p>
<pre><code>1. 包名
&gt; 包名全部小写，连续的单词只是简单地连接起来，不使用下划线。
</code></pre><ol>
<li><p>类名</p>
<blockquote>
<p>类名都以UpperCamelCase风格编写。</p>
</blockquote>
</li>
<li><p>方法名</p>
<blockquote>
<p>方法名都以lowerCamelCase风格编写。</p>
</blockquote>
</li>
<li><p>常量名</p>
<blockquote>
<p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。</p>
</blockquote>
</li>
<li><p>非常量字段名</p>
<blockquote>
<p>非常量字段名以lowerCamelCase风格编写。</p>
</blockquote>
</li>
<li><p>参数名</p>
<blockquote>
<p>参数名以lowerCamelCase风格编写。</p>
</blockquote>
</li>
<li><p>局部变量名</p>
<blockquote>
<p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
</blockquote>
<ol>
<li>类型变量名<br>类型变量可用以下两种风格之一进行命名：<br>  单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。<br>  以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="external">http://www.hawstein.com/posts/google-java-style.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://wx2.sinaimg.cn/mw690/63b4ac8dgy1ffzs5lll1oj20zk0qoq4z.jpg"
               alt="dzx" />
          <p class="site-author-name" itemprop="name">dzx</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">142</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">57</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">108</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dzx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
